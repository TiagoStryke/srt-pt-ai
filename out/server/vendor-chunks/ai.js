"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LlamaIndexAdapter: () => (/* binding */ llamaindex_adapter_exports),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoContentGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   ToolExecutionError: () => (/* binding */ ToolExecutionError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createDataStream: () => (/* binding */ createDataStream),\n/* harmony export */   createDataStreamResponse: () => (/* binding */ createDataStreamResponse),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ generateImage),\n/* harmony export */   experimental_wrapLanguageModel: () => (/* binding */ experimental_wrapLanguageModel),\n/* harmony export */   formatAssistantStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart),\n/* harmony export */   formatDataStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.jsonSchema),\n/* harmony export */   parseAssistantStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parseAssistantStreamPart),\n/* harmony export */   parseDataStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parseDataStreamPart),\n/* harmony export */   pipeDataStreamToResponse: () => (/* binding */ pipeDataStreamToResponse),\n/* harmony export */   processDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.processDataStream),\n/* harmony export */   processTextStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.processTextStream),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   tool: () => (/* binding */ tool)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name13 in all)__defProp(target, name13, {\n        get: all[name13],\n        enumerable: true\n    });\n};\n// streams/index.ts\n\n\n// core/index.ts\n\n// core/data-stream/create-data-stream.ts\n\nfunction createDataStream({ execute, onError = ()=>\"An error occurred.\" }) {\n    let controller;\n    const ongoingStreamPromises = [];\n    const stream = new ReadableStream({\n        start (controllerArg) {\n            controller = controllerArg;\n        }\n    });\n    function safeEnqueue(data) {\n        try {\n            controller.enqueue(data);\n        } catch (error) {}\n    }\n    try {\n        const result = execute({\n            writeData (data) {\n                safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"data\", [\n                    data\n                ]));\n            },\n            writeMessageAnnotation (annotation) {\n                safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"message_annotations\", [\n                    annotation\n                ]));\n            },\n            merge (streamArg) {\n                ongoingStreamPromises.push((async ()=>{\n                    const reader = streamArg.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) break;\n                        safeEnqueue(value);\n                    }\n                })().catch((error)=>{\n                    safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", onError(error)));\n                }));\n            },\n            onError\n        });\n        if (result) {\n            ongoingStreamPromises.push(result.catch((error)=>{\n                safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", onError(error)));\n            }));\n        }\n    } catch (error) {\n        safeEnqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", onError(error)));\n    }\n    const waitForStreams = new Promise(async (resolve)=>{\n        while(ongoingStreamPromises.length > 0){\n            await ongoingStreamPromises.shift();\n        }\n        resolve();\n    });\n    waitForStreams.finally(()=>{\n        try {\n            controller.close();\n        } catch (error) {}\n    });\n    return stream;\n}\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(headers, { contentType, dataStreamVersion }) {\n    const responseHeaders = new Headers(headers != null ? headers : {});\n    if (!responseHeaders.has(\"Content-Type\")) {\n        responseHeaders.set(\"Content-Type\", contentType);\n    }\n    if (dataStreamVersion !== void 0) {\n        responseHeaders.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n    }\n    return responseHeaders;\n}\n// core/data-stream/create-data-stream-response.ts\nfunction createDataStreamResponse({ status, statusText, headers, execute, onError }) {\n    return new Response(createDataStream({\n        execute,\n        onError\n    }).pipeThrough(new TextEncoderStream()), {\n        status,\n        statusText,\n        headers: prepareResponseHeaders(headers, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\n// core/util/prepare-outgoing-http-headers.ts\nfunction prepareOutgoingHttpHeaders(headers, { contentType, dataStreamVersion }) {\n    const outgoingHeaders = {};\n    if (headers != null) {\n        for (const [key, value] of Object.entries(headers)){\n            outgoingHeaders[key] = value;\n        }\n    }\n    if (outgoingHeaders[\"Content-Type\"] == null) {\n        outgoingHeaders[\"Content-Type\"] = contentType;\n    }\n    if (dataStreamVersion !== void 0) {\n        outgoingHeaders[\"X-Vercel-AI-Data-Stream\"] = dataStreamVersion;\n    }\n    return outgoingHeaders;\n}\n// core/util/write-to-server-response.ts\nfunction writeToServerResponse({ response, status, statusText, headers, stream }) {\n    response.writeHead(status != null ? status : 200, statusText, headers);\n    const reader = stream.getReader();\n    const read = async ()=>{\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                response.write(value);\n            }\n        } catch (error) {\n            throw error;\n        } finally{\n            response.end();\n        }\n    };\n    read();\n}\n// core/data-stream/pipe-data-stream-to-response.ts\nfunction pipeDataStreamToResponse(response, { status, statusText, headers, execute, onError }) {\n    writeToServerResponse({\n        response,\n        status,\n        statusText,\n        headers: prepareOutgoingHttpHeaders(headers, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        }),\n        stream: createDataStream({\n            execute,\n            onError\n        }).pipeThrough(new TextEncoderStream())\n    });\n}\n// errors/invalid-argument-error.ts\n\nvar name = \"AI_InvalidArgumentError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker);\n    }\n};\n_a = symbol;\n// util/retry-with-exponential-backoff.ts\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n    return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// util/retry-error.ts\n\nvar name2 = \"AI_RetryError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name: name2,\n            message\n        });\n        this[_a2] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker2);\n    }\n};\n_a2 = symbol2;\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// core/prompt/prepare-retries.ts\nfunction prepareRetries({ maxRetries }) {\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n    return {\n        maxRetries: maxRetriesResult,\n        retry: retryWithExponentialBackoff({\n            maxRetries: maxRetriesResult\n        })\n    };\n}\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({ operationId, telemetry }) {\n    return {\n        // standardized operation and resource name:\n        \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n        \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n        // detailed, AI SDK specific data:\n        \"ai.operationId\": operationId,\n        \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n    };\n}\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {\n    var _a13;\n    return {\n        \"ai.model.provider\": model.provider,\n        \"ai.model.id\": model.modelId,\n        // settings:\n        ...Object.entries(settings).reduce((attributes, [key, value])=>{\n            attributes[`ai.settings.${key}`] = value;\n            return attributes;\n        }, {}),\n        // add metadata as attributes:\n        ...Object.entries((_a13 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a13 : {}).reduce((attributes, [key, value])=>{\n            attributes[`ai.telemetry.metadata.${key}`] = value;\n            return attributes;\n        }, {}),\n        // request headers\n        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{\n            if (value !== void 0) {\n                attributes[`ai.request.headers.${key}`] = value;\n            }\n            return attributes;\n        }, {})\n    };\n}\n// core/telemetry/get-tracer.ts\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n    startSpan () {\n        return noopSpan;\n    },\n    startActiveSpan (name13, arg1, arg2, arg3) {\n        if (typeof arg1 === \"function\") {\n            return arg1(noopSpan);\n        }\n        if (typeof arg2 === \"function\") {\n            return arg2(noopSpan);\n        }\n        if (typeof arg3 === \"function\") {\n            return arg3(noopSpan);\n        }\n    }\n};\nvar noopSpan = {\n    spanContext () {\n        return noopSpanContext;\n    },\n    setAttribute () {\n        return this;\n    },\n    setAttributes () {\n        return this;\n    },\n    addEvent () {\n        return this;\n    },\n    addLink () {\n        return this;\n    },\n    addLinks () {\n        return this;\n    },\n    setStatus () {\n        return this;\n    },\n    updateName () {\n        return this;\n    },\n    end () {\n        return this;\n    },\n    isRecording () {\n        return false;\n    },\n    recordException () {\n        return this;\n    }\n};\nvar noopSpanContext = {\n    traceId: \"\",\n    spanId: \"\",\n    traceFlags: 0\n};\n// core/telemetry/get-tracer.ts\nfunction getTracer({ isEnabled = false, tracer } = {}) {\n    if (!isEnabled) {\n        return noopTracer;\n    }\n    if (tracer) {\n        return tracer;\n    }\n    return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.trace.getTracer(\"ai\");\n}\n// core/telemetry/record-span.ts\n\nfunction recordSpan({ name: name13, tracer, attributes, fn, endWhenDone = true }) {\n    return tracer.startActiveSpan(name13, {\n        attributes\n    }, async (span)=>{\n        try {\n            const result = await fn(span);\n            if (endWhenDone) {\n                span.end();\n            }\n            return result;\n        } catch (error) {\n            try {\n                if (error instanceof Error) {\n                    span.recordException({\n                        name: error.name,\n                        message: error.message,\n                        stack: error.stack\n                    });\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.SpanStatusCode.ERROR,\n                        message: error.message\n                    });\n                } else {\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.SpanStatusCode.ERROR\n                    });\n                }\n            } finally{\n                span.end();\n            }\n            throw error;\n        }\n    });\n}\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({ telemetry, attributes }) {\n    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n        return {};\n    }\n    return Object.entries(attributes).reduce((attributes2, [key, value])=>{\n        if (value === void 0) {\n            return attributes2;\n        }\n        if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n                return attributes2;\n            }\n            const result = value.input();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n                return attributes2;\n            }\n            const result = value.output();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        return {\n            ...attributes2,\n            [key]: value\n        };\n    }, {});\n}\n// core/embed/embed.ts\nasync function embed({ model, value, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embed\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embed\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.value\": {\n                    input: ()=>JSON.stringify(value)\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const { embedding, usage, rawResponse } = await retry(()=>// nested spans to align with the embedMany telemetry data:\n                recordSpan({\n                    name: \"ai.embed.doEmbed\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.embed.doEmbed\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            // specific settings that only make sense on the outer level:\n                            \"ai.values\": {\n                                input: ()=>[\n                                        JSON.stringify(value)\n                                    ]\n                            }\n                        }\n                    }),\n                    tracer,\n                    fn: async (doEmbedSpan)=>{\n                        var _a13;\n                        const modelResponse = await model.doEmbed({\n                            values: [\n                                value\n                            ],\n                            abortSignal,\n                            headers\n                        });\n                        const embedding2 = modelResponse.embeddings[0];\n                        const usage2 = (_a13 = modelResponse.usage) != null ? _a13 : {\n                            tokens: NaN\n                        };\n                        doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.embeddings\": {\n                                    output: ()=>modelResponse.embeddings.map((embedding3)=>JSON.stringify(embedding3))\n                                },\n                                \"ai.usage.tokens\": usage2.tokens\n                            }\n                        }));\n                        return {\n                            embedding: embedding2,\n                            usage: usage2,\n                            rawResponse: modelResponse.rawResponse\n                        };\n                    }\n                }));\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embedding\": {\n                        output: ()=>JSON.stringify(embedding)\n                    },\n                    \"ai.usage.tokens\": usage.tokens\n                }\n            }));\n            return new DefaultEmbedResult({\n                value,\n                embedding,\n                usage,\n                rawResponse\n            });\n        }\n    });\n}\nvar DefaultEmbedResult = class {\n    constructor(options){\n        this.value = options.value;\n        this.embedding = options.embedding;\n        this.usage = options.usage;\n        this.rawResponse = options.rawResponse;\n    }\n};\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n    if (chunkSize <= 0) {\n        throw new Error(\"chunkSize must be greater than 0\");\n    }\n    const result = [];\n    for(let i = 0; i < array.length; i += chunkSize){\n        result.push(array.slice(i, i + chunkSize));\n    }\n    return result;\n}\n// core/embed/embed-many.ts\nasync function embedMany({ model, values, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embedMany\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embedMany\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                    input: ()=>values.map((value)=>JSON.stringify(value))\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n            if (maxEmbeddingsPerCall == null) {\n                const { embeddings: embeddings2, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>values.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a13;\n                            const modelResponse = await model.doEmbed({\n                                values,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings3 = modelResponse.embeddings;\n                            const usage2 = (_a13 = modelResponse.usage) != null ? _a13 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings3,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                span.setAttributes(selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.embeddings\": {\n                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                    }\n                }));\n                return new DefaultEmbedManyResult({\n                    values,\n                    embeddings: embeddings2,\n                    usage\n                });\n            }\n            const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n            const embeddings = [];\n            let tokens = 0;\n            for (const chunk of valueChunks){\n                const { embeddings: responseEmbeddings, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>chunk.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a13;\n                            const modelResponse = await model.doEmbed({\n                                values: chunk,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings2 = modelResponse.embeddings;\n                            const usage2 = (_a13 = modelResponse.usage) != null ? _a13 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings2,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                embeddings.push(...responseEmbeddings);\n                tokens += usage.tokens;\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embeddings\": {\n                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": tokens\n                }\n            }));\n            return new DefaultEmbedManyResult({\n                values,\n                embeddings,\n                usage: {\n                    tokens\n                }\n            });\n        }\n    });\n}\nvar DefaultEmbedManyResult = class {\n    constructor(options){\n        this.values = options.values;\n        this.embeddings = options.embeddings;\n        this.usage = options.usage;\n    }\n};\n// core/generate-image/generate-image.ts\n\nasync function generateImage({ model, prompt, n, size, providerOptions, maxRetries: maxRetriesArg, abortSignal, headers }) {\n    const { retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const { images } = await retry(()=>model.doGenerate({\n            prompt,\n            n: n != null ? n : 1,\n            abortSignal,\n            headers,\n            size,\n            providerOptions: providerOptions != null ? providerOptions : {}\n        }));\n    return new DefaultGenerateImageResult({\n        base64Images: images\n    });\n}\nvar DefaultGenerateImageResult = class {\n    constructor(options){\n        this.images = options.base64Images.map((base64)=>({\n                base64,\n                get uint8Array () {\n                    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64);\n                }\n            }));\n    }\n    get image() {\n        return this.images[0];\n    }\n};\n// core/generate-object/generate-object.ts\n\n// errors/no-object-generated-error.ts\n\nvar name3 = \"AI_NoObjectGeneratedError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ message = \"No object generated.\", cause, text: text2, response, usage }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a3] = true;\n        this.text = text2;\n        this.response = response;\n        this.usage = usage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker3);\n    }\n};\n_a3 = symbol3;\n// util/download-error.ts\n\nvar name4 = \"AI_DownloadError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){\n        super({\n            name: name4,\n            message,\n            cause\n        });\n        this[_a4] = true;\n        this.url = url;\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker4);\n    }\n};\n_a4 = symbol4;\n// util/download.ts\nasync function download({ url, fetchImplementation = fetch }) {\n    var _a13;\n    const urlText = url.toString();\n    try {\n        const response = await fetchImplementation(urlText);\n        if (!response.ok) {\n            throw new DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a13 = response.headers.get(\"content-type\")) != null ? _a13 : void 0\n        };\n    } catch (error) {\n        if (DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name5 = \"AI_InvalidDataContentError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name5,\n            message,\n            cause\n        });\n        this[_a5] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker5);\n    }\n};\n_a5 = symbol5;\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(Uint8Array),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(ArrayBuffer),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.custom(// Buffer might not be available in some environments such as CloudFlare:\n    (value)=>{\n        var _a13, _b;\n        return (_b = (_a13 = globalThis.Buffer) == null ? void 0 : _a13.isBuffer(value)) != null ? _b : false;\n    }, {\n        message: \"Must be a Buffer\"\n    })\n]);\nfunction convertDataContentToBase64String(content) {\n    if (typeof content === \"string\") {\n        return content;\n    }\n    if (content instanceof ArrayBuffer) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(new Uint8Array(content));\n    }\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n    try {\n        return new TextDecoder().decode(uint8Array);\n    } catch (error) {\n        throw new Error(\"Error decoding Uint8Array to text\");\n    }\n}\n// core/prompt/invalid-message-role-error.ts\n\nvar name6 = \"AI_InvalidMessageRoleError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name6,\n            message\n        });\n        this[_a6] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker6);\n    }\n};\n_a6 = symbol6;\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n    try {\n        const [header, base64Content] = dataUrl.split(\",\");\n        return {\n            mimeType: header.split(\";\")[0].split(\":\")[1],\n            base64Content\n        };\n    } catch (error) {\n        return {\n            mimeType: void 0,\n            base64Content: void 0\n        };\n    }\n}\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, modelSupportsUrl = ()=>false, downloadImplementation = download }) {\n    const downloadedAssets = await downloadAssets(prompt.messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl);\n    return [\n        ...prompt.system != null ? [\n            {\n                role: \"system\",\n                content: prompt.system\n            }\n        ] : [],\n        ...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedAssets))\n    ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\").map((part)=>{\n                        const { experimental_providerMetadata, ...rest } = part;\n                        return {\n                            ...rest,\n                            providerMetadata: experimental_providerMetadata\n                        };\n                    }),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.map((part)=>({\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            result: part.result,\n                            content: part.experimental_content,\n                            isError: part.isError,\n                            providerMetadata: part.experimental_providerMetadata\n                        })),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\" || part.type === \"file\").filter((part)=>!(part.type === \"image\" && modelSupportsImageUrls === true)).map((part)=>part.type === \"image\" ? part.image : part.data).map((part)=>// support string urls:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL).filter((url)=>!modelSupportsUrl(url));\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n    var _a13;\n    if (part.type === \"text\") {\n        return {\n            type: \"text\",\n            text: part.text,\n            providerMetadata: part.experimental_providerMetadata\n        };\n    }\n    let mimeType = part.mimeType;\n    let data;\n    let content;\n    let normalizedData;\n    const type = part.type;\n    switch(type){\n        case \"image\":\n            data = part.image;\n            break;\n        case \"file\":\n            data = part.data;\n            break;\n        default:\n            throw new Error(`Unsupported part type: ${type}`);\n    }\n    try {\n        content = typeof data === \"string\" ? new URL(data) : data;\n    } catch (error) {\n        content = data;\n    }\n    if (content instanceof URL) {\n        if (content.protocol === \"data:\") {\n            const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(content.toString());\n            if (dataUrlMimeType == null || base64Content == null) {\n                throw new Error(`Invalid data URL format in part ${type}`);\n            }\n            mimeType = dataUrlMimeType;\n            normalizedData = convertDataContentToUint8Array(base64Content);\n        } else {\n            const downloadedFile = downloadedAssets[content.toString()];\n            if (downloadedFile) {\n                normalizedData = downloadedFile.data;\n                mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;\n            } else {\n                normalizedData = content;\n            }\n        }\n    } else {\n        normalizedData = convertDataContentToUint8Array(content);\n    }\n    switch(type){\n        case \"image\":\n            {\n                if (normalizedData instanceof Uint8Array) {\n                    mimeType = (_a13 = detectImageMimeType(normalizedData)) != null ? _a13 : mimeType;\n                }\n                return {\n                    type: \"image\",\n                    image: normalizedData,\n                    mimeType,\n                    providerMetadata: part.experimental_providerMetadata\n                };\n            }\n        case \"file\":\n            {\n                if (mimeType == null) {\n                    throw new Error(`Mime type is missing for file part`);\n                }\n                return {\n                    type: \"file\",\n                    data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,\n                    mimeType,\n                    providerMetadata: part.experimental_providerMetadata\n                };\n            }\n    }\n}\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, stopSequences, seed }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (topK != null) {\n        if (typeof topK !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topK\",\n                value: topK,\n                message: \"topK must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        topK,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed\n    };\n}\n// core/prompt/standardize-prompt.ts\n\n\n\n// core/prompt/message.ts\n\n// core/types/provider-metadata.ts\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.lazy(()=>zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.null(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.number(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), jsonValueSchema),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.array(jsonValueSchema)\n    ]));\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), zod__WEBPACK_IMPORTED_MODULE_4__.z.record(zod__WEBPACK_IMPORTED_MODULE_4__.z.string(), jsonValueSchema));\n// core/prompt/content-part.ts\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"text\"),\n        text: zod__WEBPACK_IMPORTED_MODULE_4__.z.string()\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"image\"),\n        data: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().optional()\n    })\n]));\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"text\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"image\"),\n    image: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"file\"),\n    data: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.instanceof(URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool-call\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    args: zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool-result\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    result: zod__WEBPACK_IMPORTED_MODULE_4__.z.unknown(),\n    content: toolResultContentSchema.optional(),\n    isError: zod__WEBPACK_IMPORTED_MODULE_4__.z.boolean().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"system\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"user\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n            textPartSchema,\n            imagePartSchema,\n            filePartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"assistant\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_4__.z.array(zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n            textPartSchema,\n            toolCallPartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_4__.z.literal(\"tool\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(toolResultPartSchema),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_4__.z.union([\n    coreSystemMessageSchema,\n    coreUserMessageSchema,\n    coreAssistantMessageSchema,\n    coreToolMessageSchema\n]);\n// core/prompt/detect-prompt-type.ts\nfunction detectPromptType(prompt) {\n    if (!Array.isArray(prompt)) {\n        return \"other\";\n    }\n    if (prompt.length === 0) {\n        return \"messages\";\n    }\n    const characteristics = prompt.map(detectSingleMessageCharacteristics);\n    if (characteristics.some((c)=>c === \"has-ui-specific-parts\")) {\n        return \"ui-messages\";\n    } else if (characteristics.every((c)=>c === \"has-core-specific-parts\" || c === \"message\")) {\n        return \"messages\";\n    } else {\n        return \"other\";\n    }\n}\nfunction detectSingleMessageCharacteristics(message) {\n    if (typeof message === \"object\" && message !== null && (message.role === \"function\" || // UI-only role\n    message.role === \"data\" || // UI-only role\n    \"toolInvocations\" in message || // UI-specific field\n    \"experimental_attachments\" in message)) {\n        return \"has-ui-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"content\" in message && (Array.isArray(message.content) || // Core messages can have array content\n    \"experimental_providerMetadata\" in message)) {\n        return \"has-core-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"role\" in message && \"content\" in message && typeof message.content === \"string\" && [\n        \"system\",\n        \"user\",\n        \"assistant\",\n        \"tool\"\n    ].includes(message.role)) {\n        return \"message\";\n    } else {\n        return \"other\";\n    }\n}\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n    var _a13, _b, _c;\n    const parts = [];\n    for (const attachment of attachments){\n        let url;\n        try {\n            url = new URL(attachment.url);\n        } catch (error) {\n            throw new Error(`Invalid URL: ${attachment.url}`);\n        }\n        switch(url.protocol){\n            case \"http:\":\n            case \"https:\":\n                {\n                    if ((_a13 = attachment.contentType) == null ? void 0 : _a13.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: url\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: url,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            case \"data:\":\n                {\n                    let header;\n                    let base64Content;\n                    let mimeType;\n                    try {\n                        [header, base64Content] = attachment.url.split(\",\");\n                        mimeType = header.split(\";\")[0].split(\":\")[1];\n                    } catch (error) {\n                        throw new Error(`Error processing data URL: ${attachment.url}`);\n                    }\n                    if (mimeType == null || base64Content == null) {\n                        throw new Error(`Invalid data URL format: ${attachment.url}`);\n                    }\n                    if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content)\n                        });\n                    } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n                        parts.push({\n                            type: \"text\",\n                            text: convertUint8ArrayToText(convertDataContentToUint8Array(base64Content))\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image or text, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: base64Content,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            default:\n                {\n                    throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                }\n        }\n    }\n    return parts;\n}\n// core/prompt/message-conversion-error.ts\n\nvar name7 = \"AI_MessageConversionError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ originalMessage, message }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a7] = true;\n        this.originalMessage = originalMessage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker7);\n    }\n};\n_a7 = symbol7;\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages, options) {\n    var _a13;\n    const tools = (_a13 = options == null ? void 0 : options.tools) != null ? _a13 : {};\n    const coreMessages = [];\n    for (const message of messages){\n        const { role, content, toolInvocations, experimental_attachments } = message;\n        switch(role){\n            case \"system\":\n                {\n                    coreMessages.push({\n                        role: \"system\",\n                        content\n                    });\n                    break;\n                }\n            case \"user\":\n                {\n                    coreMessages.push({\n                        role: \"user\",\n                        content: experimental_attachments ? [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...attachmentsToParts(experimental_attachments)\n                        ] : content\n                    });\n                    break;\n                }\n            case \"assistant\":\n                {\n                    if (toolInvocations == null) {\n                        coreMessages.push({\n                            role: \"assistant\",\n                            content\n                        });\n                        break;\n                    }\n                    coreMessages.push({\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...toolInvocations.map(({ toolCallId, toolName, args })=>({\n                                    type: \"tool-call\",\n                                    toolCallId,\n                                    toolName,\n                                    args\n                                }))\n                        ]\n                    });\n                    coreMessages.push({\n                        role: \"tool\",\n                        content: toolInvocations.map((toolInvocation)=>{\n                            if (!(\"result\" in toolInvocation)) {\n                                throw new MessageConversionError({\n                                    originalMessage: message,\n                                    message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                                });\n                            }\n                            const { toolCallId, toolName, result } = toolInvocation;\n                            const tool2 = tools[toolName];\n                            return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result: tool2.experimental_toToolResultContent(result),\n                                experimental_content: tool2.experimental_toToolResultContent(result)\n                            } : {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result\n                            };\n                        })\n                    });\n                    break;\n                }\n            case \"data\":\n                {\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = role;\n                    throw new MessageConversionError({\n                        originalMessage: message,\n                        message: `Unsupported role: ${_exhaustiveCheck}`\n                    });\n                }\n        }\n    }\n    return coreMessages;\n}\n// core/prompt/standardize-prompt.ts\nfunction standardizePrompt({ prompt, tools }) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.system != null && typeof prompt.system !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n            prompt,\n            message: \"system must be a string\"\n        });\n    }\n    if (prompt.prompt != null) {\n        if (typeof prompt.prompt !== \"string\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n                prompt,\n                message: \"prompt must be a string\"\n            });\n        }\n        return {\n            type: \"prompt\",\n            system: prompt.system,\n            messages: [\n                {\n                    role: \"user\",\n                    content: prompt.prompt\n                }\n            ]\n        };\n    }\n    if (prompt.messages != null) {\n        const promptType = detectPromptType(prompt.messages);\n        if (promptType === \"other\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\"\n            });\n        }\n        const messages = promptType === \"ui-messages\" ? convertToCoreMessages(prompt.messages, {\n            tools\n        }) : prompt.messages;\n        const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n            value: messages,\n            schema: zod__WEBPACK_IMPORTED_MODULE_4__.z.array(coreMessageSchema)\n        });\n        if (!validationResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\",\n                cause: validationResult.error\n            });\n        }\n        return {\n            type: \"messages\",\n            messages,\n            system: prompt.system\n        };\n    }\n    throw new Error(\"unreachable\");\n}\n// core/types/usage.ts\nfunction calculateLanguageModelUsage({ promptTokens, completionTokens }) {\n    return {\n        promptTokens,\n        completionTokens,\n        totalTokens: promptTokens + completionTokens\n    };\n}\nfunction addLanguageModelUsage(usage1, usage2) {\n    return {\n        promptTokens: usage1.promptTokens + usage2.promptTokens,\n        completionTokens: usage1.completionTokens + usage2.completionTokens,\n        totalTokens: usage1.totalTokens + usage2.totalTokens\n    };\n}\n// core/generate-object/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({ prompt, schema, schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0, schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX }) {\n    return [\n        prompt != null && prompt.length > 0 ? prompt : void 0,\n        prompt != null && prompt.length > 0 ? \"\" : void 0,\n        // add a newline if prompt is not null\n        schemaPrefix,\n        schema != null ? JSON.stringify(schema) : void 0,\n        schemaSuffix\n    ].filter((line)=>line != null).join(\"\\n\");\n}\n// core/generate-object/output-strategy.ts\n\n\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n    const stream = source.pipeThrough(new TransformStream());\n    stream[Symbol.asyncIterator] = ()=>{\n        const reader = stream.getReader();\n        return {\n            async next () {\n                const { done, value } = await reader.read();\n                return done ? {\n                    done: true,\n                    value: void 0\n                } : {\n                    done: false,\n                    value\n                };\n            }\n        };\n    };\n    return stream;\n}\n// core/generate-object/output-strategy.ts\nvar noSchemaOutputStrategy = {\n    type: \"no-schema\",\n    jsonSchema: void 0,\n    validatePartialResult ({ value, textDelta }) {\n        return {\n            success: true,\n            value: {\n                partial: value,\n                textDelta\n            }\n        };\n    },\n    validateFinalResult (value, context) {\n        return value === void 0 ? {\n            success: false,\n            error: new NoObjectGeneratedError({\n                message: \"No object generated: response did not match schema.\",\n                text: context.text,\n                response: context.response,\n                usage: context.usage\n            })\n        } : {\n            success: true,\n            value\n        };\n    },\n    createElementStream () {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n            functionality: \"element streams in no-schema mode\"\n        });\n    }\n};\nvar objectOutputStrategy = (schema)=>({\n        type: \"object\",\n        jsonSchema: schema.jsonSchema,\n        validatePartialResult ({ value, textDelta }) {\n            return {\n                success: true,\n                value: {\n                    // Note: currently no validation of partial results:\n                    partial: value,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                value,\n                schema\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"element streams in object mode\"\n            });\n        }\n    });\nvar arrayOutputStrategy = (schema)=>{\n    const { $schema, ...itemSchema } = schema.jsonSchema;\n    return {\n        type: \"enum\",\n        // wrap in object that contains array of elements, since most LLMs will not\n        // be able to generate an array directly:\n        // possible future optimization: use arrays directly when model supports grammar-guided generation\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                elements: {\n                    type: \"array\",\n                    items: itemSchema\n                }\n            },\n            required: [\n                \"elements\"\n            ],\n            additionalProperties: false\n        },\n        validatePartialResult ({ value, latestObject, isFirstDelta, isFinalDelta }) {\n            var _a13;\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            const resultArray = [];\n            for(let i = 0; i < inputArray.length; i++){\n                const element = inputArray[i];\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (i === inputArray.length - 1 && !isFinalDelta) {\n                    continue;\n                }\n                if (!result.success) {\n                    return result;\n                }\n                resultArray.push(result.value);\n            }\n            const publishedElementCount = (_a13 = latestObject == null ? void 0 : latestObject.length) != null ? _a13 : 0;\n            let textDelta = \"\";\n            if (isFirstDelta) {\n                textDelta += \"[\";\n            }\n            if (publishedElementCount > 0) {\n                textDelta += \",\";\n            }\n            textDelta += resultArray.slice(publishedElementCount).map((element)=>JSON.stringify(element)).join(\",\");\n            if (isFinalDelta) {\n                textDelta += \"]\";\n            }\n            return {\n                success: true,\n                value: {\n                    partial: resultArray,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            for (const element of inputArray){\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (!result.success) {\n                    return result;\n                }\n            }\n            return {\n                success: true,\n                value: inputArray\n            };\n        },\n        createElementStream (originalStream) {\n            let publishedElements = 0;\n            return createAsyncIterableStream(originalStream.pipeThrough(new TransformStream({\n                transform (chunk, controller) {\n                    switch(chunk.type){\n                        case \"object\":\n                            {\n                                const array = chunk.object;\n                                for(; publishedElements < array.length; publishedElements++){\n                                    controller.enqueue(array[publishedElements]);\n                                }\n                                break;\n                            }\n                        case \"text-delta\":\n                        case \"finish\":\n                            break;\n                        case \"error\":\n                            controller.error(chunk.error);\n                            break;\n                        default:\n                            {\n                                const _exhaustiveCheck = chunk;\n                                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                            }\n                    }\n                }\n            })));\n        }\n    };\n};\nvar enumOutputStrategy = (enumValues)=>{\n    return {\n        type: \"enum\",\n        // wrap in object that contains result, since most LLMs will not\n        // be able to generate an enum value directly:\n        // possible future optimization: use enums directly when model supports top-level enums\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                result: {\n                    type: \"string\",\n                    enum: enumValues\n                }\n            },\n            required: [\n                \"result\"\n            ],\n            additionalProperties: false\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.isJSONObject)(value) || typeof value.result !== \"string\") {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n                        value,\n                        cause: 'value must be an object that contains a string in the \"result\" property.'\n                    })\n                };\n            }\n            const result = value.result;\n            return enumValues.includes(result) ? {\n                success: true,\n                value: result\n            } : {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError({\n                    value,\n                    cause: \"value must be a string in the enum\"\n                })\n            };\n        },\n        validatePartialResult () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"partial results in enum mode\"\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"element streams in enum mode\"\n            });\n        }\n    };\n};\nfunction getOutputStrategy({ output, schema, enumValues }) {\n    switch(output){\n        case \"object\":\n            return objectOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(schema));\n        case \"array\":\n            return arrayOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(schema));\n        case \"enum\":\n            return enumOutputStrategy(enumValues);\n        case \"no-schema\":\n            return noSchemaOutputStrategy;\n        default:\n            {\n                const _exhaustiveCheck = output;\n                throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n            }\n    }\n}\n// core/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({ output, mode, schema, schemaName, schemaDescription, enumValues }) {\n    if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n        throw new InvalidArgumentError({\n            parameter: \"output\",\n            value: output,\n            message: \"Invalid output type.\"\n        });\n    }\n    if (output === \"no-schema\") {\n        if (mode === \"auto\" || mode === \"tool\") {\n            throw new InvalidArgumentError({\n                parameter: \"mode\",\n                value: mode,\n                message: 'Mode must be \"json\" for no-schema output.'\n            });\n        }\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for no-schema output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for no-schema output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for no-schema output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for no-schema output.\"\n            });\n        }\n    }\n    if (output === \"object\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is required for object output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for object output.\"\n            });\n        }\n    }\n    if (output === \"array\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Element schema is required for array output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for array output.\"\n            });\n        }\n    }\n    if (output === \"enum\") {\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for enum output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for enum output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for enum output.\"\n            });\n        }\n        if (enumValues == null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are required for enum output.\"\n            });\n        }\n        for (const value of enumValues){\n            if (typeof value !== \"string\") {\n                throw new InvalidArgumentError({\n                    parameter: \"enumValues\",\n                    value,\n                    message: \"Enum values must be strings.\"\n                });\n            }\n        }\n    }\n}\n// core/generate-object/generate-object.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function generateObject({ model, enum: enumValues, // rename bc enum is reserved by typescript\nschema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, _internal: { generateId: generateId3 = originalGenerateId, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription,\n        enumValues\n    });\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema,\n        enumValues\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateObject\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateObject\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                    input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                } : void 0,\n                \"ai.schema.name\": schemaName,\n                \"ai.schema.description\": schemaDescription,\n                \"ai.settings.output\": outputStrategy.type,\n                \"ai.settings.mode\": mode\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a13, _b;\n            if (mode === \"auto\" || mode == null) {\n                mode = model.defaultObjectGenerationMode;\n            }\n            let result;\n            let finishReason;\n            let usage;\n            let warnings;\n            let rawResponse;\n            let response;\n            let request;\n            let logprobs;\n            let resultProviderMetadata;\n            switch(mode){\n                case \"json\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                    prompt: system\n                                }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                    prompt: system,\n                                    schema: outputStrategy.jsonSchema\n                                }),\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: model.supportsUrl\n                        });\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>standardizedPrompt.type\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a14, _b2, _c, _d, _e, _f;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-json\",\n                                            schema: outputStrategy.jsonSchema,\n                                            name: schemaName,\n                                            description: schemaDescription\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat: standardizedPrompt.type,\n                                        prompt: promptMessages,\n                                        providerMetadata,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    const responseData = {\n                                        id: (_b2 = (_a14 = result2.response) == null ? void 0 : _a14.id) != null ? _b2 : generateId3(),\n                                        timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                                        modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId\n                                    };\n                                    if (result2.text === void 0) {\n                                        throw new NoObjectGeneratedError({\n                                            message: \"No object generated: the model did not return a response.\",\n                                            response: responseData,\n                                            usage: calculateLanguageModelUsage(result2.usage)\n                                        });\n                                    }\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>result2.text\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText: result2.text,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_a13 = generateResult.request) != null ? _a13 : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case \"tool\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system,\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: model.supportsUrl\n                        });\n                        const inputFormat = standardizedPrompt.type;\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>inputFormat\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a14, _b2, _c, _d, _e, _f, _g, _h;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-tool\",\n                                            tool: {\n                                                type: \"function\",\n                                                name: schemaName != null ? schemaName : \"json\",\n                                                description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                                parameters: outputStrategy.jsonSchema\n                                            }\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat,\n                                        prompt: promptMessages,\n                                        providerMetadata,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    const objectText = (_b2 = (_a14 = result2.toolCalls) == null ? void 0 : _a14[0]) == null ? void 0 : _b2.args;\n                                    const responseData = {\n                                        id: (_d = (_c = result2.response) == null ? void 0 : _c.id) != null ? _d : generateId3(),\n                                        timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),\n                                        modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId\n                                    };\n                                    if (objectText === void 0) {\n                                        throw new NoObjectGeneratedError({\n                                            message: \"No object generated: the tool was not called.\",\n                                            response: responseData,\n                                            usage: calculateLanguageModelUsage(result2.usage)\n                                        });\n                                    }\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>objectText\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.input_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.output_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_b = generateResult.request) != null ? _b : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case void 0:\n                    {\n                        throw new Error(\"Model does not have a default object generation mode.\");\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = mode;\n                        throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                    }\n            }\n            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: result\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: result,\n                    response,\n                    usage: calculateLanguageModelUsage(usage)\n                });\n            }\n            const validationResult = outputStrategy.validateFinalResult(parseResult.value, {\n                text: result,\n                response,\n                usage: calculateLanguageModelUsage(usage)\n            });\n            if (!validationResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: response did not match schema.\",\n                    cause: validationResult.error,\n                    text: result,\n                    response,\n                    usage: calculateLanguageModelUsage(usage)\n                });\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": finishReason,\n                    \"ai.response.object\": {\n                        output: ()=>JSON.stringify(validationResult.value)\n                    },\n                    \"ai.usage.promptTokens\": usage.promptTokens,\n                    \"ai.usage.completionTokens\": usage.completionTokens\n                }\n            }));\n            return new DefaultGenerateObjectResult({\n                object: validationResult.value,\n                finishReason,\n                usage: calculateLanguageModelUsage(usage),\n                warnings,\n                request,\n                response: {\n                    ...response,\n                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                },\n                logprobs,\n                providerMetadata: resultProviderMetadata\n            });\n        }\n    });\n}\nvar DefaultGenerateObjectResult = class {\n    constructor(options){\n        this.object = options.object;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.response = options.response;\n        this.request = options.request;\n        this.logprobs = options.logprobs;\n    }\n    toJsonResponse(init) {\n        var _a13;\n        return new Response(JSON.stringify(this.object), {\n            status: (_a13 = init == null ? void 0 : init.status) != null ? _a13 : 200,\n            headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"application/json; charset=utf-8\"\n            })\n        });\n    }\n};\n// core/generate-object/stream-object.ts\n\n\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n    constructor(){\n        this.status = {\n            type: \"pending\"\n        };\n        this._resolve = void 0;\n        this._reject = void 0;\n    }\n    get value() {\n        if (this.promise) {\n            return this.promise;\n        }\n        this.promise = new Promise((resolve, reject)=>{\n            if (this.status.type === \"resolved\") {\n                resolve(this.status.value);\n            } else if (this.status.type === \"rejected\") {\n                reject(this.status.error);\n            }\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        return this.promise;\n    }\n    resolve(value) {\n        var _a13;\n        this.status = {\n            type: \"resolved\",\n            value\n        };\n        if (this.promise) {\n            (_a13 = this._resolve) == null ? void 0 : _a13.call(this, value);\n        }\n    }\n    reject(error) {\n        var _a13;\n        this.status = {\n            type: \"rejected\",\n            error\n        };\n        if (this.promise) {\n            (_a13 = this._reject) == null ? void 0 : _a13.call(this, error);\n        }\n    }\n};\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// core/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n    let innerStreamReaders = [];\n    let controller = null;\n    let isClosed = false;\n    let waitForNewStream = createResolvablePromise();\n    const processPull = async ()=>{\n        if (isClosed && innerStreamReaders.length === 0) {\n            controller == null ? void 0 : controller.close();\n            return;\n        }\n        if (innerStreamReaders.length === 0) {\n            waitForNewStream = createResolvablePromise();\n            await waitForNewStream.promise;\n            return processPull();\n        }\n        try {\n            const { value, done } = await innerStreamReaders[0].read();\n            if (done) {\n                innerStreamReaders.shift();\n                if (innerStreamReaders.length > 0) {\n                    await processPull();\n                } else if (isClosed) {\n                    controller == null ? void 0 : controller.close();\n                }\n            } else {\n                controller == null ? void 0 : controller.enqueue(value);\n            }\n        } catch (error) {\n            controller == null ? void 0 : controller.error(error);\n            innerStreamReaders.shift();\n            if (isClosed && innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        }\n    };\n    return {\n        stream: new ReadableStream({\n            start (controllerParam) {\n                controller = controllerParam;\n            },\n            pull: processPull,\n            async cancel () {\n                for (const reader of innerStreamReaders){\n                    await reader.cancel();\n                }\n                innerStreamReaders = [];\n                isClosed = true;\n            }\n        }),\n        addStream: (innerStream)=>{\n            if (isClosed) {\n                throw new Error(\"Cannot add inner stream: outer stream is closed\");\n            }\n            innerStreamReaders.push(innerStream.getReader());\n            waitForNewStream.resolve();\n        },\n        close: ()=>{\n            isClosed = true;\n            waitForNewStream.resolve();\n            if (innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        }\n    };\n}\n// core/util/now.ts\nfunction now() {\n    var _a13, _b;\n    return (_b = (_a13 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a13.now()) != null ? _b : Date.now();\n}\n// core/generate-object/stream-object.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nfunction streamObject({ model, schema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, onFinish, _internal: { generateId: generateId3 = originalGenerateId2, currentDate = ()=>/* @__PURE__ */ new Date(), now: now2 = now } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    return new DefaultStreamObjectResult({\n        model,\n        telemetry,\n        headers,\n        settings,\n        maxRetries,\n        abortSignal,\n        outputStrategy,\n        system,\n        prompt,\n        messages,\n        schemaName,\n        schemaDescription,\n        inputProviderMetadata: providerMetadata,\n        mode,\n        onFinish,\n        generateId: generateId3,\n        currentDate,\n        now: now2\n    });\n}\nvar DefaultStreamObjectResult = class {\n    constructor({ model, headers, telemetry, settings, maxRetries: maxRetriesArg, abortSignal, outputStrategy, system, prompt, messages, schemaName, schemaDescription, inputProviderMetadata, mode, onFinish, generateId: generateId3, currentDate, now: now2 }){\n        this.objectPromise = new DelayedPromise();\n        this.usagePromise = new DelayedPromise();\n        this.providerMetadataPromise = new DelayedPromise();\n        this.warningsPromise = new DelayedPromise();\n        this.requestPromise = new DelayedPromise();\n        this.responsePromise = new DelayedPromise();\n        this.stitchableStream = createStitchableStream();\n        const { maxRetries, retry } = prepareRetries({\n            maxRetries: maxRetriesArg\n        });\n        const baseTelemetryAttributes = getBaseTelemetryAttributes({\n            model,\n            telemetry,\n            headers,\n            settings: {\n                ...settings,\n                maxRetries\n            }\n        });\n        const tracer = getTracer(telemetry);\n        const self = this;\n        recordSpan({\n            name: \"ai.streamObject\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.streamObject\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    },\n                    \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                        input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                    } : void 0,\n                    \"ai.schema.name\": schemaName,\n                    \"ai.schema.description\": schemaDescription,\n                    \"ai.settings.output\": outputStrategy.type,\n                    \"ai.settings.mode\": mode\n                }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (rootSpan)=>{\n                if (mode === \"auto\" || mode == null) {\n                    mode = model.defaultObjectGenerationMode;\n                }\n                let callOptions;\n                let transformer;\n                switch(mode){\n                    case \"json\":\n                        {\n                            const standardizedPrompt = standardizePrompt({\n                                prompt: {\n                                    system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                        prompt: system\n                                    }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                        prompt: system,\n                                        schema: outputStrategy.jsonSchema\n                                    }),\n                                    prompt,\n                                    messages\n                                },\n                                tools: void 0\n                            });\n                            callOptions = {\n                                mode: {\n                                    type: \"object-json\",\n                                    schema: outputStrategy.jsonSchema,\n                                    name: schemaName,\n                                    description: schemaDescription\n                                },\n                                ...prepareCallSettings(settings),\n                                inputFormat: standardizedPrompt.type,\n                                prompt: await convertToLanguageModelPrompt({\n                                    prompt: standardizedPrompt,\n                                    modelSupportsImageUrls: model.supportsImageUrls,\n                                    modelSupportsUrl: model.supportsUrl\n                                }),\n                                providerMetadata: inputProviderMetadata,\n                                abortSignal,\n                                headers\n                            };\n                            transformer = {\n                                transform: (chunk, controller)=>{\n                                    switch(chunk.type){\n                                        case \"text-delta\":\n                                            controller.enqueue(chunk.textDelta);\n                                            break;\n                                        case \"response-metadata\":\n                                        case \"finish\":\n                                        case \"error\":\n                                            controller.enqueue(chunk);\n                                            break;\n                                    }\n                                }\n                            };\n                            break;\n                        }\n                    case \"tool\":\n                        {\n                            const standardizedPrompt = standardizePrompt({\n                                prompt: {\n                                    system,\n                                    prompt,\n                                    messages\n                                },\n                                tools: void 0\n                            });\n                            callOptions = {\n                                mode: {\n                                    type: \"object-tool\",\n                                    tool: {\n                                        type: \"function\",\n                                        name: schemaName != null ? schemaName : \"json\",\n                                        description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                        parameters: outputStrategy.jsonSchema\n                                    }\n                                },\n                                ...prepareCallSettings(settings),\n                                inputFormat: standardizedPrompt.type,\n                                prompt: await convertToLanguageModelPrompt({\n                                    prompt: standardizedPrompt,\n                                    modelSupportsImageUrls: model.supportsImageUrls,\n                                    modelSupportsUrl: model.supportsUrl\n                                }),\n                                providerMetadata: inputProviderMetadata,\n                                abortSignal,\n                                headers\n                            };\n                            transformer = {\n                                transform (chunk, controller) {\n                                    switch(chunk.type){\n                                        case \"tool-call-delta\":\n                                            controller.enqueue(chunk.argsTextDelta);\n                                            break;\n                                        case \"response-metadata\":\n                                        case \"finish\":\n                                        case \"error\":\n                                            controller.enqueue(chunk);\n                                            break;\n                                    }\n                                }\n                            };\n                            break;\n                        }\n                    case void 0:\n                        {\n                            throw new Error(\"Model does not have a default object generation mode.\");\n                        }\n                    default:\n                        {\n                            const _exhaustiveCheck = mode;\n                            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                        }\n                }\n                const { result: { stream, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                        name: \"ai.streamObject.doStream\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.streamObject.doStream\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>callOptions.inputFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(callOptions.prompt)\n                                },\n                                \"ai.settings.mode\": mode,\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        endWhenDone: false,\n                        fn: async (doStreamSpan2)=>({\n                                startTimestampMs: now2(),\n                                doStreamSpan: doStreamSpan2,\n                                result: await model.doStream(callOptions)\n                            })\n                    }));\n                self.requestPromise.resolve(request != null ? request : {});\n                let usage;\n                let finishReason;\n                let providerMetadata;\n                let object2;\n                let error;\n                let accumulatedText = \"\";\n                let textDelta = \"\";\n                let response = {\n                    id: generateId3(),\n                    timestamp: currentDate(),\n                    modelId: model.modelId\n                };\n                let latestObjectJson = void 0;\n                let latestObject = void 0;\n                let isFirstChunk = true;\n                let isFirstDelta = true;\n                const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(new TransformStream({\n                    async transform (chunk, controller) {\n                        var _a13, _b, _c;\n                        if (isFirstChunk) {\n                            const msToFirstChunk = now2() - startTimestampMs;\n                            isFirstChunk = false;\n                            doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                                \"ai.stream.msToFirstChunk\": msToFirstChunk\n                            });\n                            doStreamSpan.setAttributes({\n                                \"ai.stream.msToFirstChunk\": msToFirstChunk\n                            });\n                        }\n                        if (typeof chunk === \"string\") {\n                            accumulatedText += chunk;\n                            textDelta += chunk;\n                            const { value: currentObjectJson, state: parseState } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.parsePartialJson)(accumulatedText);\n                            if (currentObjectJson !== void 0 && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.isDeepEqualData)(latestObjectJson, currentObjectJson)) {\n                                const validationResult = outputStrategy.validatePartialResult({\n                                    value: currentObjectJson,\n                                    textDelta,\n                                    latestObject,\n                                    isFirstDelta,\n                                    isFinalDelta: parseState === \"successful-parse\"\n                                });\n                                if (validationResult.success && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.isDeepEqualData)(latestObject, validationResult.value.partial)) {\n                                    latestObjectJson = currentObjectJson;\n                                    latestObject = validationResult.value.partial;\n                                    controller.enqueue({\n                                        type: \"object\",\n                                        object: latestObject\n                                    });\n                                    controller.enqueue({\n                                        type: \"text-delta\",\n                                        textDelta: validationResult.value.textDelta\n                                    });\n                                    textDelta = \"\";\n                                    isFirstDelta = false;\n                                }\n                            }\n                            return;\n                        }\n                        switch(chunk.type){\n                            case \"response-metadata\":\n                                {\n                                    response = {\n                                        id: (_a13 = chunk.id) != null ? _a13 : response.id,\n                                        timestamp: (_b = chunk.timestamp) != null ? _b : response.timestamp,\n                                        modelId: (_c = chunk.modelId) != null ? _c : response.modelId\n                                    };\n                                    break;\n                                }\n                            case \"finish\":\n                                {\n                                    if (textDelta !== \"\") {\n                                        controller.enqueue({\n                                            type: \"text-delta\",\n                                            textDelta\n                                        });\n                                    }\n                                    finishReason = chunk.finishReason;\n                                    usage = calculateLanguageModelUsage(chunk.usage);\n                                    providerMetadata = chunk.providerMetadata;\n                                    controller.enqueue({\n                                        ...chunk,\n                                        usage,\n                                        response\n                                    });\n                                    self.usagePromise.resolve(usage);\n                                    self.providerMetadataPromise.resolve(providerMetadata);\n                                    self.responsePromise.resolve({\n                                        ...response,\n                                        headers: rawResponse == null ? void 0 : rawResponse.headers\n                                    });\n                                    const validationResult = outputStrategy.validateFinalResult(latestObjectJson, {\n                                        text: accumulatedText,\n                                        response,\n                                        usage\n                                    });\n                                    if (validationResult.success) {\n                                        object2 = validationResult.value;\n                                        self.objectPromise.resolve(object2);\n                                    } else {\n                                        error = new NoObjectGeneratedError({\n                                            message: \"No object generated: response did not match schema.\",\n                                            cause: validationResult.error,\n                                            text: accumulatedText,\n                                            response,\n                                            usage\n                                        });\n                                        self.objectPromise.reject(error);\n                                    }\n                                    break;\n                                }\n                            default:\n                                {\n                                    controller.enqueue(chunk);\n                                    break;\n                                }\n                        }\n                    },\n                    // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                    async flush (controller) {\n                        try {\n                            const finalUsage = usage != null ? usage : {\n                                promptTokens: NaN,\n                                completionTokens: NaN,\n                                totalTokens: NaN\n                            };\n                            doStreamSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": finishReason,\n                                    \"ai.response.object\": {\n                                        output: ()=>JSON.stringify(object2)\n                                    },\n                                    \"ai.response.id\": response.id,\n                                    \"ai.response.model\": response.modelId,\n                                    \"ai.response.timestamp\": response.timestamp.toISOString(),\n                                    \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                                    \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        finishReason\n                                    ],\n                                    \"gen_ai.response.id\": response.id,\n                                    \"gen_ai.response.model\": response.modelId,\n                                    \"gen_ai.usage.input_tokens\": finalUsage.promptTokens,\n                                    \"gen_ai.usage.output_tokens\": finalUsage.completionTokens\n                                }\n                            }));\n                            doStreamSpan.end();\n                            rootSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                                    \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                                    \"ai.response.object\": {\n                                        output: ()=>JSON.stringify(object2)\n                                    }\n                                }\n                            }));\n                            await (onFinish == null ? void 0 : onFinish({\n                                usage: finalUsage,\n                                object: object2,\n                                error,\n                                response: {\n                                    ...response,\n                                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                                },\n                                warnings,\n                                experimental_providerMetadata: providerMetadata\n                            }));\n                        } catch (error2) {\n                            controller.error(error2);\n                        } finally{\n                            rootSpan.end();\n                        }\n                    }\n                }));\n                self.stitchableStream.addStream(transformedStream);\n            }\n        }).catch((error)=>{\n            self.stitchableStream.addStream(new ReadableStream({\n                start (controller) {\n                    controller.error(error);\n                }\n            }));\n        }).finally(()=>{\n            self.stitchableStream.close();\n        });\n        this.outputStrategy = outputStrategy;\n    }\n    get object() {\n        return this.objectPromise.value;\n    }\n    get usage() {\n        return this.usagePromise.value;\n    }\n    get experimental_providerMetadata() {\n        return this.providerMetadataPromise.value;\n    }\n    get warnings() {\n        return this.warningsPromise.value;\n    }\n    get request() {\n        return this.requestPromise.value;\n    }\n    get response() {\n        return this.responsePromise.value;\n    }\n    get partialObjectStream() {\n        return createAsyncIterableStream(this.stitchableStream.stream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"object\":\n                        controller.enqueue(chunk.object);\n                        break;\n                    case \"text-delta\":\n                    case \"finish\":\n                        break;\n                    case \"error\":\n                        controller.error(chunk.error);\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        })));\n    }\n    get elementStream() {\n        return this.outputStrategy.createElementStream(this.stitchableStream.stream);\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.stitchableStream.stream.pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"text-delta\":\n                        controller.enqueue(chunk.textDelta);\n                        break;\n                    case \"object\":\n                    case \"finish\":\n                        break;\n                    case \"error\":\n                        controller.error(chunk.error);\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        })));\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.stitchableStream.stream);\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a13;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a13 = init == null ? void 0 : init.status) != null ? _a13 : 200,\n            headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\n// core/generate-text/generate-text.ts\n\n// errors/index.ts\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name8 = \"AI_InvalidToolArgumentsError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(cause)}` }){\n        super({\n            name: name8,\n            message,\n            cause\n        });\n        this[_a8] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker8);\n    }\n};\n_a8 = symbol8;\n// errors/no-such-tool-error.ts\n\nvar name9 = \"AI_NoSuchToolError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name9,\n            message\n        });\n        this[_a9] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker9);\n    }\n};\n_a9 = symbol9;\n// errors/tool-call-repair-error.ts\n\nvar name10 = \"AI_ToolCallRepairError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ cause, originalError, message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(cause)}` }){\n        super({\n            name: name10,\n            message,\n            cause\n        });\n        this[_a10] = true;\n        this.originalError = originalError;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker10);\n    }\n};\n_a10 = symbol10;\n// errors/tool-execution-error.ts\n\nvar name11 = \"AI_ToolExecutionError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar ToolExecutionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Error executing tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(cause)}` }){\n        super({\n            name: name11,\n            message,\n            cause\n        });\n        this[_a11] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker11);\n    }\n};\n_a11 = symbol11;\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n    return object2 != null && Object.keys(object2).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name13])=>activeTools.includes(name13)) : Object.entries(tools);\n    return {\n        tools: filteredTools.map(([name13, tool2])=>{\n            const toolType = tool2.type;\n            switch(toolType){\n                case void 0:\n                case \"function\":\n                    return {\n                        type: \"function\",\n                        name: name13,\n                        description: tool2.description,\n                        parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tool2.parameters).jsonSchema\n                    };\n                case \"provider-defined\":\n                    return {\n                        type: \"provider-defined\",\n                        name: name13,\n                        id: tool2.id,\n                        args: tool2.args\n                    };\n                default:\n                    {\n                        const exhaustiveCheck = toolType;\n                        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n                    }\n            }\n        }),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// core/util/split-on-last-whitespace.ts\nvar lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\nfunction splitOnLastWhitespace(text2) {\n    const match = text2.match(lastWhitespaceRegexp);\n    return match ? {\n        prefix: match[1],\n        whitespace: match[2],\n        suffix: match[3]\n    } : void 0;\n}\n// core/util/remove-text-after-last-whitespace.ts\nfunction removeTextAfterLastWhitespace(text2) {\n    const match = splitOnLastWhitespace(text2);\n    return match ? match.prefix + match.whitespace : text2;\n}\n// core/generate-text/parse-tool-call.ts\n\n\nasync function parseToolCall({ toolCall, tools, repairToolCall, system, messages }) {\n    if (tools == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName\n        });\n    }\n    try {\n        return await doParseToolCall({\n            toolCall,\n            tools\n        });\n    } catch (error) {\n        if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolArgumentsError.isInstance(error))) {\n            throw error;\n        }\n        let repairedToolCall = null;\n        try {\n            repairedToolCall = await repairToolCall({\n                toolCall,\n                tools,\n                parameterSchema: ({ toolName })=>(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tools[toolName].parameters).jsonSchema,\n                system,\n                messages,\n                error\n            });\n        } catch (repairError) {\n            throw new ToolCallRepairError({\n                cause: repairError,\n                originalError: error\n            });\n        }\n        if (repairedToolCall == null) {\n            throw error;\n        }\n        return await doParseToolCall({\n            toolCall: repairedToolCall,\n            tools\n        });\n    }\n}\nasync function doParseToolCall({ toolCall, tools }) {\n    const toolName = toolCall.toolName;\n    const tool2 = tools[toolName];\n    if (tool2 == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName,\n            availableTools: Object.keys(tools)\n        });\n    }\n    const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tool2.parameters);\n    const parseResult = toolCall.args.trim() === \"\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: {},\n        schema\n    }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n        text: toolCall.args,\n        schema\n    });\n    if (parseResult.success === false) {\n        throw new InvalidToolArgumentsError({\n            toolName,\n            toolArgs: toolCall.args,\n            cause: parseResult.error\n        });\n    }\n    return {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName,\n        args: parseResult.value\n    };\n}\n// core/generate-text/to-response-messages.ts\nfunction toResponseMessages({ text: text2 = \"\", tools, toolCalls, toolResults }) {\n    const responseMessages = [];\n    responseMessages.push({\n        role: \"assistant\",\n        content: [\n            {\n                type: \"text\",\n                text: text2\n            },\n            ...toolCalls\n        ]\n    });\n    if (toolResults.length > 0) {\n        responseMessages.push({\n            role: \"tool\",\n            content: toolResults.map((toolResult)=>{\n                const tool2 = tools[toolResult.toolName];\n                return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: tool2.experimental_toToolResultContent(toolResult.result),\n                    experimental_content: tool2.experimental_toToolResultContent(toolResult.result)\n                } : {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: toolResult.result\n                };\n            })\n        });\n    }\n    return responseMessages;\n}\n// core/generate-text/generate-text.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nasync function generateText({ model, tools, toolChoice, system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, headers, maxSteps = 1, experimental_output: output, experimental_continueSteps: continueSteps = false, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, experimental_activeTools: activeTools, experimental_repairToolCall: repairToolCall, _internal: { generateId: generateId3 = originalGenerateId3, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, onStepFinish, ...settings }) {\n    var _a13;\n    if (maxSteps < 1) {\n        throw new InvalidArgumentError({\n            parameter: \"maxSteps\",\n            value: maxSteps,\n            message: \"maxSteps must be at least 1\"\n        });\n    }\n    const { maxRetries, retry } = prepareRetries({\n        maxRetries: maxRetriesArg\n    });\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const initialPrompt = standardizePrompt({\n        prompt: {\n            system: (_a13 = output == null ? void 0 : output.injectIntoSystemPrompt({\n                system,\n                model\n            })) != null ? _a13 : system,\n            prompt,\n            messages\n        },\n        tools\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateText\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateText\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.settings.maxSteps\": maxSteps\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a14, _b, _c, _d, _e, _f;\n            const mode = {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice,\n                    activeTools\n                })\n            };\n            const callSettings = prepareCallSettings(settings);\n            let currentModelResponse;\n            let currentToolCalls = [];\n            let currentToolResults = [];\n            let stepCount = 0;\n            const responseMessages = [];\n            let text2 = \"\";\n            const steps = [];\n            let usage = {\n                completionTokens: 0,\n                promptTokens: 0,\n                totalTokens: 0\n            };\n            let stepType = \"initial\";\n            do {\n                const promptFormat = stepCount === 0 ? initialPrompt.type : \"messages\";\n                const stepInputMessages = [\n                    ...initialPrompt.messages,\n                    ...responseMessages\n                ];\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: {\n                        type: promptFormat,\n                        system: initialPrompt.system,\n                        messages: stepInputMessages\n                    },\n                    modelSupportsImageUrls: model.supportsImageUrls,\n                    modelSupportsUrl: model.supportsUrl\n                });\n                currentModelResponse = await retry(()=>recordSpan({\n                        name: \"ai.generateText.doGenerate\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.generateText.doGenerate\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>promptFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(promptMessages)\n                                },\n                                \"ai.prompt.tools\": {\n                                    // convert the language model level tools:\n                                    input: ()=>{\n                                        var _a15;\n                                        return (_a15 = mode.tools) == null ? void 0 : _a15.map((tool2)=>JSON.stringify(tool2));\n                                    }\n                                },\n                                \"ai.prompt.toolChoice\": {\n                                    input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        fn: async (span2)=>{\n                            var _a15, _b2, _c2, _d2, _e2, _f2;\n                            const result = await model.doGenerate({\n                                mode,\n                                ...callSettings,\n                                inputFormat: promptFormat,\n                                responseFormat: output == null ? void 0 : output.responseFormat({\n                                    model\n                                }),\n                                prompt: promptMessages,\n                                providerMetadata,\n                                abortSignal,\n                                headers\n                            });\n                            const responseData = {\n                                id: (_b2 = (_a15 = result.response) == null ? void 0 : _a15.id) != null ? _b2 : generateId3(),\n                                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                                modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : model.modelId\n                            };\n                            span2.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": result.finishReason,\n                                    \"ai.response.text\": {\n                                        output: ()=>result.text\n                                    },\n                                    \"ai.response.toolCalls\": {\n                                        output: ()=>JSON.stringify(result.toolCalls)\n                                    },\n                                    \"ai.response.id\": responseData.id,\n                                    \"ai.response.model\": responseData.modelId,\n                                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        result.finishReason\n                                    ],\n                                    \"gen_ai.response.id\": responseData.id,\n                                    \"gen_ai.response.model\": responseData.modelId,\n                                    \"gen_ai.usage.input_tokens\": result.usage.promptTokens,\n                                    \"gen_ai.usage.output_tokens\": result.usage.completionTokens\n                                }\n                            }));\n                            return {\n                                ...result,\n                                response: responseData\n                            };\n                        }\n                    }));\n                currentToolCalls = await Promise.all(((_a14 = currentModelResponse.toolCalls) != null ? _a14 : []).map((toolCall)=>parseToolCall({\n                        toolCall,\n                        tools,\n                        repairToolCall,\n                        system,\n                        messages: stepInputMessages\n                    })));\n                currentToolResults = tools == null ? [] : await executeTools({\n                    toolCalls: currentToolCalls,\n                    tools,\n                    tracer,\n                    telemetry,\n                    messages: stepInputMessages,\n                    abortSignal\n                });\n                const currentUsage = calculateLanguageModelUsage(currentModelResponse.usage);\n                usage = addLanguageModelUsage(usage, currentUsage);\n                let nextStepType = \"done\";\n                if (++stepCount < maxSteps) {\n                    if (continueSteps && currentModelResponse.finishReason === \"length\" && // only use continue when there are no tool calls:\n                    currentToolCalls.length === 0) {\n                        nextStepType = \"continue\";\n                    } else if (// there are tool calls:\n                    currentToolCalls.length > 0 && // all current tool calls have results:\n                    currentToolResults.length === currentToolCalls.length) {\n                        nextStepType = \"tool-result\";\n                    }\n                }\n                const originalText = (_b = currentModelResponse.text) != null ? _b : \"\";\n                const stepTextLeadingWhitespaceTrimmed = stepType === \"continue\" && // only for continue steps\n                text2.trimEnd() !== text2 ? originalText.trimStart() : originalText;\n                const stepText = nextStepType === \"continue\" ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed) : stepTextLeadingWhitespaceTrimmed;\n                text2 = nextStepType === \"continue\" || stepType === \"continue\" ? text2 + stepText : stepText;\n                if (stepType === \"continue\") {\n                    const lastMessage = responseMessages[responseMessages.length - 1];\n                    if (typeof lastMessage.content === \"string\") {\n                        lastMessage.content += stepText;\n                    } else {\n                        lastMessage.content.push({\n                            text: stepText,\n                            type: \"text\"\n                        });\n                    }\n                } else {\n                    responseMessages.push(...toResponseMessages({\n                        text: text2,\n                        tools: tools != null ? tools : {},\n                        toolCalls: currentToolCalls,\n                        toolResults: currentToolResults\n                    }));\n                }\n                const currentStepResult = {\n                    stepType,\n                    text: stepText,\n                    toolCalls: currentToolCalls,\n                    toolResults: currentToolResults,\n                    finishReason: currentModelResponse.finishReason,\n                    usage: currentUsage,\n                    warnings: currentModelResponse.warnings,\n                    logprobs: currentModelResponse.logprobs,\n                    request: (_c = currentModelResponse.request) != null ? _c : {},\n                    response: {\n                        ...currentModelResponse.response,\n                        headers: (_d = currentModelResponse.rawResponse) == null ? void 0 : _d.headers,\n                        // deep clone msgs to avoid mutating past messages in multi-step:\n                        messages: JSON.parse(JSON.stringify(responseMessages))\n                    },\n                    experimental_providerMetadata: currentModelResponse.providerMetadata,\n                    isContinued: nextStepType === \"continue\"\n                };\n                steps.push(currentStepResult);\n                await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                stepType = nextStepType;\n            }while (stepType !== \"done\");\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": currentModelResponse.finishReason,\n                    \"ai.response.text\": {\n                        output: ()=>currentModelResponse.text\n                    },\n                    \"ai.response.toolCalls\": {\n                        output: ()=>JSON.stringify(currentModelResponse.toolCalls)\n                    },\n                    \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n                    \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens\n                }\n            }));\n            return new DefaultGenerateTextResult({\n                text: text2,\n                output: output == null ? void 0 : output.parseOutput({\n                    text: text2\n                }, {\n                    response: currentModelResponse.response,\n                    usage\n                }),\n                toolCalls: currentToolCalls,\n                toolResults: currentToolResults,\n                finishReason: currentModelResponse.finishReason,\n                usage,\n                warnings: currentModelResponse.warnings,\n                request: (_e = currentModelResponse.request) != null ? _e : {},\n                response: {\n                    ...currentModelResponse.response,\n                    headers: (_f = currentModelResponse.rawResponse) == null ? void 0 : _f.headers,\n                    messages: responseMessages\n                },\n                logprobs: currentModelResponse.logprobs,\n                steps,\n                providerMetadata: currentModelResponse.providerMetadata\n            });\n        }\n    });\n}\nasync function executeTools({ toolCalls, tools, tracer, telemetry, messages, abortSignal }) {\n    const toolResults = await Promise.all(toolCalls.map(async ({ toolCallId, toolName, args })=>{\n        const tool2 = tools[toolName];\n        if ((tool2 == null ? void 0 : tool2.execute) == null) {\n            return void 0;\n        }\n        const result = await recordSpan({\n            name: \"ai.toolCall\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.toolCall\",\n                        telemetry\n                    }),\n                    \"ai.toolCall.name\": toolName,\n                    \"ai.toolCall.id\": toolCallId,\n                    \"ai.toolCall.args\": {\n                        output: ()=>JSON.stringify(args)\n                    }\n                }\n            }),\n            tracer,\n            fn: async (span)=>{\n                try {\n                    const result2 = await tool2.execute(args, {\n                        toolCallId,\n                        messages,\n                        abortSignal\n                    });\n                    try {\n                        span.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.toolCall.result\": {\n                                    output: ()=>JSON.stringify(result2)\n                                }\n                            }\n                        }));\n                    } catch (ignored) {}\n                    return result2;\n                } catch (error) {\n                    throw new ToolExecutionError({\n                        toolName,\n                        toolArgs: args,\n                        cause: error\n                    });\n                }\n            }\n        });\n        return {\n            type: \"tool-result\",\n            toolCallId,\n            toolName,\n            args,\n            result\n        };\n    }));\n    return toolResults.filter((result)=>result != null);\n}\nvar DefaultGenerateTextResult = class {\n    constructor(options){\n        this.text = options.text;\n        this.toolCalls = options.toolCalls;\n        this.toolResults = options.toolResults;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.request = options.request;\n        this.response = options.response;\n        this.steps = options.steps;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.logprobs = options.logprobs;\n        this.experimental_output = options.output;\n    }\n};\n// core/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n    object: ()=>object,\n    text: ()=>text\n});\n\n\nvar text = ()=>({\n        type: \"text\",\n        responseFormat: ()=>({\n                type: \"text\"\n            }),\n        injectIntoSystemPrompt ({ system }) {\n            return system;\n        },\n        parseOutput ({ text: text2 }) {\n            return text2;\n        }\n    });\nvar object = ({ schema: inputSchema })=>{\n    const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(inputSchema);\n    return {\n        type: \"object\",\n        responseFormat: ({ model })=>({\n                type: \"json\",\n                schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0\n            }),\n        injectIntoSystemPrompt ({ system, model }) {\n            return model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                prompt: system,\n                schema: schema.jsonSchema\n            });\n        },\n        parseOutput ({ text: text2 }, context) {\n            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({\n                text: text2\n            });\n            if (!parseResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: could not parse the response.\",\n                    cause: parseResult.error,\n                    text: text2,\n                    response: context.response,\n                    usage: context.usage\n                });\n            }\n            const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n                value: parseResult.value,\n                schema\n            });\n            if (!validationResult.success) {\n                throw new NoObjectGeneratedError({\n                    message: \"No object generated: response did not match schema.\",\n                    cause: validationResult.error,\n                    text: text2,\n                    response: context.response,\n                    usage: context.usage\n                });\n            }\n            return validationResult.value;\n        }\n    };\n};\n// core/generate-text/stream-text.ts\n\n\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n    const reader1 = stream1.getReader();\n    const reader2 = stream2.getReader();\n    let lastRead1 = void 0;\n    let lastRead2 = void 0;\n    let stream1Done = false;\n    let stream2Done = false;\n    async function readStream1(controller) {\n        try {\n            if (lastRead1 == null) {\n                lastRead1 = reader1.read();\n            }\n            const result = await lastRead1;\n            lastRead1 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    async function readStream2(controller) {\n        try {\n            if (lastRead2 == null) {\n                lastRead2 = reader2.read();\n            }\n            const result = await lastRead2;\n            lastRead2 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    return new ReadableStream({\n        async pull (controller) {\n            try {\n                if (stream1Done) {\n                    await readStream2(controller);\n                    return;\n                }\n                if (stream2Done) {\n                    await readStream1(controller);\n                    return;\n                }\n                if (lastRead1 == null) {\n                    lastRead1 = reader1.read();\n                }\n                if (lastRead2 == null) {\n                    lastRead2 = reader2.read();\n                }\n                const { result, reader } = await Promise.race([\n                    lastRead1.then((result2)=>({\n                            result: result2,\n                            reader: reader1\n                        })),\n                    lastRead2.then((result2)=>({\n                            result: result2,\n                            reader: reader2\n                        }))\n                ]);\n                if (!result.done) {\n                    controller.enqueue(result.value);\n                }\n                if (reader === reader1) {\n                    lastRead1 = void 0;\n                    if (result.done) {\n                        await readStream2(controller);\n                        stream1Done = true;\n                    }\n                } else {\n                    lastRead2 = void 0;\n                    if (result.done) {\n                        stream2Done = true;\n                        await readStream1(controller);\n                    }\n                }\n            } catch (error) {\n                controller.error(error);\n            }\n        },\n        cancel () {\n            reader1.cancel();\n            reader2.cancel();\n        }\n    });\n}\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({ tools, generatorStream, toolCallStreaming, tracer, telemetry, system, messages, abortSignal, repairToolCall }) {\n    let toolResultsStreamController = null;\n    const toolResultsStream = new ReadableStream({\n        start (controller) {\n            toolResultsStreamController = controller;\n        }\n    });\n    const activeToolCalls = {};\n    const outstandingToolResults = /* @__PURE__ */ new Set();\n    let canClose = false;\n    let finishChunk = void 0;\n    function attemptClose() {\n        if (canClose && outstandingToolResults.size === 0) {\n            if (finishChunk != null) {\n                toolResultsStreamController.enqueue(finishChunk);\n            }\n            toolResultsStreamController.close();\n        }\n    }\n    const forwardStream = new TransformStream({\n        async transform (chunk, controller) {\n            const chunkType = chunk.type;\n            switch(chunkType){\n                case \"text-delta\":\n                case \"response-metadata\":\n                case \"error\":\n                    {\n                        controller.enqueue(chunk);\n                        break;\n                    }\n                case \"tool-call-delta\":\n                    {\n                        if (toolCallStreaming) {\n                            if (!activeToolCalls[chunk.toolCallId]) {\n                                controller.enqueue({\n                                    type: \"tool-call-streaming-start\",\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName\n                                });\n                                activeToolCalls[chunk.toolCallId] = true;\n                            }\n                            controller.enqueue({\n                                type: \"tool-call-delta\",\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                argsTextDelta: chunk.argsTextDelta\n                            });\n                        }\n                        break;\n                    }\n                case \"tool-call\":\n                    {\n                        try {\n                            const toolCall = await parseToolCall({\n                                toolCall: chunk,\n                                tools,\n                                repairToolCall,\n                                system,\n                                messages\n                            });\n                            controller.enqueue(toolCall);\n                            const tool2 = tools[toolCall.toolName];\n                            if (tool2.execute != null) {\n                                const toolExecutionId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n                                outstandingToolResults.add(toolExecutionId);\n                                recordSpan({\n                                    name: \"ai.toolCall\",\n                                    attributes: selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            ...assembleOperationName({\n                                                operationId: \"ai.toolCall\",\n                                                telemetry\n                                            }),\n                                            \"ai.toolCall.name\": toolCall.toolName,\n                                            \"ai.toolCall.id\": toolCall.toolCallId,\n                                            \"ai.toolCall.args\": {\n                                                output: ()=>JSON.stringify(toolCall.args)\n                                            }\n                                        }\n                                    }),\n                                    tracer,\n                                    fn: async (span)=>tool2.execute(toolCall.args, {\n                                            toolCallId: toolCall.toolCallId,\n                                            messages,\n                                            abortSignal\n                                        }).then((result)=>{\n                                            toolResultsStreamController.enqueue({\n                                                ...toolCall,\n                                                type: \"tool-result\",\n                                                result\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                            try {\n                                                span.setAttributes(selectTelemetryAttributes({\n                                                    telemetry,\n                                                    attributes: {\n                                                        \"ai.toolCall.result\": {\n                                                            output: ()=>JSON.stringify(result)\n                                                        }\n                                                    }\n                                                }));\n                                            } catch (ignored) {}\n                                        }, (error)=>{\n                                            toolResultsStreamController.enqueue({\n                                                type: \"error\",\n                                                error: new ToolExecutionError({\n                                                    toolName: toolCall.toolName,\n                                                    toolArgs: toolCall.args,\n                                                    cause: error\n                                                })\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                        })\n                                });\n                            }\n                        } catch (error) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error\n                            });\n                        }\n                        break;\n                    }\n                case \"finish\":\n                    {\n                        finishChunk = {\n                            type: \"finish\",\n                            finishReason: chunk.finishReason,\n                            logprobs: chunk.logprobs,\n                            usage: calculateLanguageModelUsage(chunk.usage),\n                            experimental_providerMetadata: chunk.providerMetadata\n                        };\n                        break;\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = chunkType;\n                        throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n                    }\n            }\n        },\n        flush () {\n            canClose = true;\n            attemptClose();\n        }\n    });\n    return new ReadableStream({\n        async start (controller) {\n            return Promise.all([\n                generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {}\n                })),\n                toolResultsStream.pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {\n                        controller.close();\n                    }\n                }))\n            ]);\n        }\n    });\n}\n// core/generate-text/stream-text.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nfunction streamText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, maxSteps = 1, experimental_continueSteps: continueSteps = false, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, experimental_toolCallStreaming: toolCallStreaming = false, experimental_activeTools: activeTools, experimental_repairToolCall: repairToolCall, experimental_transform: transform, onChunk, onFinish, onStepFinish, _internal: { now: now2 = now, generateId: generateId3 = originalGenerateId4, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    return new DefaultStreamTextResult({\n        model,\n        telemetry,\n        headers,\n        settings,\n        maxRetries,\n        abortSignal,\n        system,\n        prompt,\n        messages,\n        tools,\n        toolChoice,\n        toolCallStreaming,\n        transform: transform == null ? void 0 : transform({\n            tools\n        }),\n        activeTools,\n        repairToolCall,\n        maxSteps,\n        continueSteps,\n        providerMetadata,\n        onChunk,\n        onFinish,\n        onStepFinish,\n        now: now2,\n        currentDate,\n        generateId: generateId3\n    });\n}\nvar DefaultStreamTextResult = class {\n    constructor({ model, telemetry, headers, settings, maxRetries: maxRetriesArg, abortSignal, system, prompt, messages, tools, toolChoice, toolCallStreaming, transform, activeTools, repairToolCall, maxSteps, continueSteps, providerMetadata, onChunk, onFinish, onStepFinish, now: now2, currentDate, generateId: generateId3 }){\n        this.warningsPromise = new DelayedPromise();\n        this.usagePromise = new DelayedPromise();\n        this.finishReasonPromise = new DelayedPromise();\n        this.providerMetadataPromise = new DelayedPromise();\n        this.textPromise = new DelayedPromise();\n        this.toolCallsPromise = new DelayedPromise();\n        this.toolResultsPromise = new DelayedPromise();\n        this.requestPromise = new DelayedPromise();\n        this.responsePromise = new DelayedPromise();\n        this.stepsPromise = new DelayedPromise();\n        if (maxSteps < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxSteps\",\n                value: maxSteps,\n                message: \"maxSteps must be at least 1\"\n            });\n        }\n        let recordedStepText = \"\";\n        let recordedContinuationText = \"\";\n        let recordedFullText = \"\";\n        let recordedRequest = void 0;\n        const recordedResponse = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId: model.modelId,\n            messages: []\n        };\n        let recordedToolCalls = [];\n        let recordedToolResults = [];\n        let recordedFinishReason = void 0;\n        let recordedUsage = void 0;\n        let recordedProviderMetadata = void 0;\n        let stepType = \"initial\";\n        const recordedSteps = [];\n        let rootSpan;\n        const eventProcessor = new TransformStream({\n            async transform (chunk, controller) {\n                controller.enqueue(chunk);\n                if (chunk.type === \"text-delta\" || chunk.type === \"tool-call\" || chunk.type === \"tool-result\" || chunk.type === \"tool-call-streaming-start\" || chunk.type === \"tool-call-delta\") {\n                    await (onChunk == null ? void 0 : onChunk({\n                        chunk\n                    }));\n                }\n                if (chunk.type === \"text-delta\") {\n                    recordedStepText += chunk.textDelta;\n                    recordedContinuationText += chunk.textDelta;\n                    recordedFullText += chunk.textDelta;\n                }\n                if (chunk.type === \"tool-call\") {\n                    recordedToolCalls.push(chunk);\n                }\n                if (chunk.type === \"tool-result\") {\n                    recordedToolResults.push(chunk);\n                }\n                if (chunk.type === \"step-finish\") {\n                    const stepMessages = toResponseMessages({\n                        text: recordedContinuationText,\n                        tools: tools != null ? tools : {},\n                        toolCalls: recordedToolCalls,\n                        toolResults: recordedToolResults\n                    });\n                    const currentStep = recordedSteps.length;\n                    let nextStepType = \"done\";\n                    if (currentStep + 1 < maxSteps) {\n                        if (continueSteps && chunk.finishReason === \"length\" && // only use continue when there are no tool calls:\n                        recordedToolCalls.length === 0) {\n                            nextStepType = \"continue\";\n                        } else if (// there are tool calls:\n                        recordedToolCalls.length > 0 && // all current tool calls have results:\n                        recordedToolResults.length === recordedToolCalls.length) {\n                            nextStepType = \"tool-result\";\n                        }\n                    }\n                    const currentStepResult = {\n                        stepType,\n                        text: recordedStepText,\n                        toolCalls: recordedToolCalls,\n                        toolResults: recordedToolResults,\n                        finishReason: chunk.finishReason,\n                        usage: chunk.usage,\n                        warnings: chunk.warnings,\n                        logprobs: chunk.logprobs,\n                        request: chunk.request,\n                        response: {\n                            ...chunk.response,\n                            messages: [\n                                ...recordedResponse.messages,\n                                ...stepMessages\n                            ]\n                        },\n                        experimental_providerMetadata: chunk.experimental_providerMetadata,\n                        isContinued: chunk.isContinued\n                    };\n                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                    recordedSteps.push(currentStepResult);\n                    recordedToolCalls = [];\n                    recordedToolResults = [];\n                    recordedStepText = \"\";\n                    recordedRequest = chunk.request;\n                    if (nextStepType !== \"done\") {\n                        stepType = nextStepType;\n                    }\n                    if (nextStepType !== \"continue\") {\n                        recordedResponse.messages.push(...stepMessages);\n                        recordedContinuationText = \"\";\n                    }\n                }\n                if (chunk.type === \"finish\") {\n                    recordedResponse.id = chunk.response.id;\n                    recordedResponse.timestamp = chunk.response.timestamp;\n                    recordedResponse.modelId = chunk.response.modelId;\n                    recordedResponse.headers = chunk.response.headers;\n                    recordedUsage = chunk.usage;\n                    recordedFinishReason = chunk.finishReason;\n                    recordedProviderMetadata = chunk.experimental_providerMetadata;\n                }\n            },\n            async flush (controller) {\n                var _a13;\n                try {\n                    const lastStep = recordedSteps[recordedSteps.length - 1];\n                    if (lastStep) {\n                        self.warningsPromise.resolve(lastStep.warnings);\n                        self.requestPromise.resolve(lastStep.request);\n                        self.responsePromise.resolve(lastStep.response);\n                        self.toolCallsPromise.resolve(lastStep.toolCalls);\n                        self.toolResultsPromise.resolve(lastStep.toolResults);\n                        self.providerMetadataPromise.resolve(lastStep.experimental_providerMetadata);\n                    }\n                    const finishReason = recordedFinishReason != null ? recordedFinishReason : \"unknown\";\n                    const usage = recordedUsage != null ? recordedUsage : {\n                        completionTokens: NaN,\n                        promptTokens: NaN,\n                        totalTokens: NaN\n                    };\n                    self.finishReasonPromise.resolve(finishReason);\n                    self.usagePromise.resolve(usage);\n                    self.textPromise.resolve(recordedFullText);\n                    self.stepsPromise.resolve(recordedSteps);\n                    await (onFinish == null ? void 0 : onFinish({\n                        finishReason,\n                        logprobs: void 0,\n                        usage,\n                        text: recordedFullText,\n                        toolCalls: lastStep.toolCalls,\n                        toolResults: lastStep.toolResults,\n                        request: (_a13 = lastStep.request) != null ? _a13 : {},\n                        response: lastStep.response,\n                        warnings: lastStep.warnings,\n                        experimental_providerMetadata: lastStep.experimental_providerMetadata,\n                        steps: recordedSteps\n                    }));\n                    rootSpan.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.response.finishReason\": finishReason,\n                            \"ai.response.text\": {\n                                output: ()=>recordedFullText\n                            },\n                            \"ai.response.toolCalls\": {\n                                output: ()=>{\n                                    var _a14;\n                                    return ((_a14 = lastStep.toolCalls) == null ? void 0 : _a14.length) ? JSON.stringify(lastStep.toolCalls) : void 0;\n                                }\n                            },\n                            \"ai.usage.promptTokens\": usage.promptTokens,\n                            \"ai.usage.completionTokens\": usage.completionTokens\n                        }\n                    }));\n                } catch (error) {\n                    controller.error(error);\n                } finally{\n                    rootSpan.end();\n                }\n            }\n        });\n        const stitchableStream = createStitchableStream();\n        this.addStream = stitchableStream.addStream;\n        this.closeStream = stitchableStream.close;\n        this.baseStream = (transform ? stitchableStream.stream.pipeThrough(transform) : stitchableStream.stream).pipeThrough(eventProcessor);\n        const { maxRetries, retry } = prepareRetries({\n            maxRetries: maxRetriesArg\n        });\n        const tracer = getTracer(telemetry);\n        const baseTelemetryAttributes = getBaseTelemetryAttributes({\n            model,\n            telemetry,\n            headers,\n            settings: {\n                ...settings,\n                maxRetries\n            }\n        });\n        const initialPrompt = standardizePrompt({\n            prompt: {\n                system,\n                prompt,\n                messages\n            },\n            tools\n        });\n        const self = this;\n        recordSpan({\n            name: \"ai.streamText\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.streamText\",\n                        telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.prompt\": {\n                        input: ()=>JSON.stringify({\n                                system,\n                                prompt,\n                                messages\n                            })\n                    },\n                    \"ai.settings.maxSteps\": maxSteps\n                }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (rootSpanArg)=>{\n                rootSpan = rootSpanArg;\n                async function streamStep({ currentStep, responseMessages, usage, stepType: stepType2, previousStepText, hasLeadingWhitespace }) {\n                    const promptFormat = responseMessages.length === 0 ? initialPrompt.type : \"messages\";\n                    const stepInputMessages = [\n                        ...initialPrompt.messages,\n                        ...responseMessages\n                    ];\n                    const promptMessages = await convertToLanguageModelPrompt({\n                        prompt: {\n                            type: promptFormat,\n                            system: initialPrompt.system,\n                            messages: stepInputMessages\n                        },\n                        modelSupportsImageUrls: model.supportsImageUrls,\n                        modelSupportsUrl: model.supportsUrl\n                    });\n                    const mode = {\n                        type: \"regular\",\n                        ...prepareToolsAndToolChoice({\n                            tools,\n                            toolChoice,\n                            activeTools\n                        })\n                    };\n                    const { result: { stream, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                            name: \"ai.streamText.doStream\",\n                            attributes: selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    ...assembleOperationName({\n                                        operationId: \"ai.streamText.doStream\",\n                                        telemetry\n                                    }),\n                                    ...baseTelemetryAttributes,\n                                    \"ai.prompt.format\": {\n                                        input: ()=>promptFormat\n                                    },\n                                    \"ai.prompt.messages\": {\n                                        input: ()=>JSON.stringify(promptMessages)\n                                    },\n                                    \"ai.prompt.tools\": {\n                                        // convert the language model level tools:\n                                        input: ()=>{\n                                            var _a13;\n                                            return (_a13 = mode.tools) == null ? void 0 : _a13.map((tool2)=>JSON.stringify(tool2));\n                                        }\n                                    },\n                                    \"ai.prompt.toolChoice\": {\n                                        input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                    },\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.system\": model.provider,\n                                    \"gen_ai.request.model\": model.modelId,\n                                    \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                    \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                    \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                    \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                    \"gen_ai.request.temperature\": settings.temperature,\n                                    \"gen_ai.request.top_k\": settings.topK,\n                                    \"gen_ai.request.top_p\": settings.topP\n                                }\n                            }),\n                            tracer,\n                            endWhenDone: false,\n                            fn: async (doStreamSpan2)=>({\n                                    startTimestampMs: now2(),\n                                    // get before the call\n                                    doStreamSpan: doStreamSpan2,\n                                    result: await model.doStream({\n                                        mode,\n                                        ...prepareCallSettings(settings),\n                                        inputFormat: promptFormat,\n                                        prompt: promptMessages,\n                                        providerMetadata,\n                                        abortSignal,\n                                        headers\n                                    })\n                                })\n                        }));\n                    const transformedStream = runToolsTransformation({\n                        tools,\n                        generatorStream: stream,\n                        toolCallStreaming,\n                        tracer,\n                        telemetry,\n                        system,\n                        messages: stepInputMessages,\n                        repairToolCall,\n                        abortSignal\n                    });\n                    const stepRequest = request != null ? request : {};\n                    const stepToolCalls = [];\n                    const stepToolResults = [];\n                    let stepFinishReason = \"unknown\";\n                    let stepUsage = {\n                        promptTokens: 0,\n                        completionTokens: 0,\n                        totalTokens: 0\n                    };\n                    let stepProviderMetadata;\n                    let stepFirstChunk = true;\n                    let stepText = \"\";\n                    let fullStepText = stepType2 === \"continue\" ? previousStepText : \"\";\n                    let stepLogProbs;\n                    let stepResponse = {\n                        id: generateId3(),\n                        timestamp: currentDate(),\n                        modelId: model.modelId\n                    };\n                    let chunkBuffer = \"\";\n                    let chunkTextPublished = false;\n                    let inWhitespacePrefix = true;\n                    let hasWhitespaceSuffix = false;\n                    async function publishTextChunk({ controller, chunk }) {\n                        controller.enqueue(chunk);\n                        stepText += chunk.textDelta;\n                        fullStepText += chunk.textDelta;\n                        chunkTextPublished = true;\n                        hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n                    }\n                    self.addStream(transformedStream.pipeThrough(new TransformStream({\n                        async transform (chunk, controller) {\n                            var _a13, _b, _c;\n                            if (stepFirstChunk) {\n                                const msToFirstChunk = now2() - startTimestampMs;\n                                stepFirstChunk = false;\n                                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                                    \"ai.response.msToFirstChunk\": msToFirstChunk\n                                });\n                                doStreamSpan.setAttributes({\n                                    \"ai.response.msToFirstChunk\": msToFirstChunk\n                                });\n                            }\n                            if (chunk.type === \"text-delta\" && chunk.textDelta.length === 0) {\n                                return;\n                            }\n                            const chunkType = chunk.type;\n                            switch(chunkType){\n                                case \"text-delta\":\n                                    {\n                                        if (continueSteps) {\n                                            const trimmedChunkText = inWhitespacePrefix && hasLeadingWhitespace ? chunk.textDelta.trimStart() : chunk.textDelta;\n                                            if (trimmedChunkText.length === 0) {\n                                                break;\n                                            }\n                                            inWhitespacePrefix = false;\n                                            chunkBuffer += trimmedChunkText;\n                                            const split = splitOnLastWhitespace(chunkBuffer);\n                                            if (split != null) {\n                                                chunkBuffer = split.suffix;\n                                                await publishTextChunk({\n                                                    controller,\n                                                    chunk: {\n                                                        type: \"text-delta\",\n                                                        textDelta: split.prefix + split.whitespace\n                                                    }\n                                                });\n                                            }\n                                        } else {\n                                            await publishTextChunk({\n                                                controller,\n                                                chunk\n                                            });\n                                        }\n                                        break;\n                                    }\n                                case \"tool-call\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepToolCalls.push(chunk);\n                                        break;\n                                    }\n                                case \"tool-result\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepToolResults.push(chunk);\n                                        break;\n                                    }\n                                case \"response-metadata\":\n                                    {\n                                        stepResponse = {\n                                            id: (_a13 = chunk.id) != null ? _a13 : stepResponse.id,\n                                            timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,\n                                            modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId\n                                        };\n                                        break;\n                                    }\n                                case \"finish\":\n                                    {\n                                        stepUsage = chunk.usage;\n                                        stepFinishReason = chunk.finishReason;\n                                        stepProviderMetadata = chunk.experimental_providerMetadata;\n                                        stepLogProbs = chunk.logprobs;\n                                        const msToFinish = now2() - startTimestampMs;\n                                        doStreamSpan.addEvent(\"ai.stream.finish\");\n                                        doStreamSpan.setAttributes({\n                                            \"ai.response.msToFinish\": msToFinish,\n                                            \"ai.response.avgCompletionTokensPerSecond\": 1e3 * stepUsage.completionTokens / msToFinish\n                                        });\n                                        break;\n                                    }\n                                case \"tool-call-streaming-start\":\n                                case \"tool-call-delta\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        break;\n                                    }\n                                case \"error\":\n                                    {\n                                        controller.enqueue(chunk);\n                                        stepFinishReason = \"error\";\n                                        break;\n                                    }\n                                default:\n                                    {\n                                        const exhaustiveCheck = chunkType;\n                                        throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                                    }\n                            }\n                        },\n                        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                        async flush (controller) {\n                            const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                            let nextStepType = \"done\";\n                            if (currentStep + 1 < maxSteps) {\n                                if (continueSteps && stepFinishReason === \"length\" && // only use continue when there are no tool calls:\n                                stepToolCalls.length === 0) {\n                                    nextStepType = \"continue\";\n                                } else if (// there are tool calls:\n                                stepToolCalls.length > 0 && // all current tool calls have results:\n                                stepToolResults.length === stepToolCalls.length) {\n                                    nextStepType = \"tool-result\";\n                                }\n                            }\n                            if (continueSteps && chunkBuffer.length > 0 && (nextStepType !== \"continue\" || // when the next step is a regular step, publish the buffer\n                            stepType2 === \"continue\" && !chunkTextPublished)) {\n                                await publishTextChunk({\n                                    controller,\n                                    chunk: {\n                                        type: \"text-delta\",\n                                        textDelta: chunkBuffer\n                                    }\n                                });\n                                chunkBuffer = \"\";\n                            }\n                            try {\n                                doStreamSpan.setAttributes(selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        \"ai.response.finishReason\": stepFinishReason,\n                                        \"ai.response.text\": {\n                                            output: ()=>stepText\n                                        },\n                                        \"ai.response.toolCalls\": {\n                                            output: ()=>stepToolCallsJson\n                                        },\n                                        \"ai.response.id\": stepResponse.id,\n                                        \"ai.response.model\": stepResponse.modelId,\n                                        \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                                        \"ai.usage.promptTokens\": stepUsage.promptTokens,\n                                        \"ai.usage.completionTokens\": stepUsage.completionTokens,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.response.finish_reasons\": [\n                                            stepFinishReason\n                                        ],\n                                        \"gen_ai.response.id\": stepResponse.id,\n                                        \"gen_ai.response.model\": stepResponse.modelId,\n                                        \"gen_ai.usage.input_tokens\": stepUsage.promptTokens,\n                                        \"gen_ai.usage.output_tokens\": stepUsage.completionTokens\n                                    }\n                                }));\n                            } catch (error) {} finally{\n                                doStreamSpan.end();\n                            }\n                            controller.enqueue({\n                                type: \"step-finish\",\n                                finishReason: stepFinishReason,\n                                usage: stepUsage,\n                                experimental_providerMetadata: stepProviderMetadata,\n                                logprobs: stepLogProbs,\n                                request: stepRequest,\n                                response: {\n                                    ...stepResponse,\n                                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                                },\n                                warnings,\n                                isContinued: nextStepType === \"continue\"\n                            });\n                            const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n                            if (nextStepType === \"done\") {\n                                controller.enqueue({\n                                    type: \"finish\",\n                                    finishReason: stepFinishReason,\n                                    usage: combinedUsage,\n                                    experimental_providerMetadata: stepProviderMetadata,\n                                    logprobs: stepLogProbs,\n                                    response: {\n                                        ...stepResponse,\n                                        headers: rawResponse == null ? void 0 : rawResponse.headers\n                                    }\n                                });\n                                self.closeStream();\n                            } else {\n                                if (stepType2 === \"continue\") {\n                                    const lastMessage = responseMessages[responseMessages.length - 1];\n                                    if (typeof lastMessage.content === \"string\") {\n                                        lastMessage.content += stepText;\n                                    } else {\n                                        lastMessage.content.push({\n                                            text: stepText,\n                                            type: \"text\"\n                                        });\n                                    }\n                                } else {\n                                    responseMessages.push(...toResponseMessages({\n                                        text: stepText,\n                                        tools: tools != null ? tools : {},\n                                        toolCalls: stepToolCalls,\n                                        toolResults: stepToolResults\n                                    }));\n                                }\n                                await streamStep({\n                                    currentStep: currentStep + 1,\n                                    responseMessages,\n                                    usage: combinedUsage,\n                                    stepType: nextStepType,\n                                    previousStepText: fullStepText,\n                                    hasLeadingWhitespace: hasWhitespaceSuffix\n                                });\n                            }\n                        }\n                    })));\n                }\n                await streamStep({\n                    currentStep: 0,\n                    responseMessages: [],\n                    usage: {\n                        promptTokens: 0,\n                        completionTokens: 0,\n                        totalTokens: 0\n                    },\n                    previousStepText: \"\",\n                    stepType: \"initial\",\n                    hasLeadingWhitespace: false\n                });\n            }\n        }).catch((error)=>{\n            self.addStream(new ReadableStream({\n                start (controller) {\n                    controller.enqueue({\n                        type: \"error\",\n                        error\n                    });\n                    controller.close();\n                }\n            }));\n            self.closeStream();\n        });\n    }\n    get warnings() {\n        return this.warningsPromise.value;\n    }\n    get usage() {\n        return this.usagePromise.value;\n    }\n    get finishReason() {\n        return this.finishReasonPromise.value;\n    }\n    get experimental_providerMetadata() {\n        return this.providerMetadataPromise.value;\n    }\n    get text() {\n        return this.textPromise.value;\n    }\n    get toolCalls() {\n        return this.toolCallsPromise.value;\n    }\n    get toolResults() {\n        return this.toolResultsPromise.value;\n    }\n    get request() {\n        return this.requestPromise.value;\n    }\n    get response() {\n        return this.responsePromise.value;\n    }\n    get steps() {\n        return this.stepsPromise.value;\n    }\n    /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */ teeStream() {\n        const [stream1, stream2] = this.baseStream.tee();\n        this.baseStream = stream2;\n        return stream1;\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({\n            transform (chunk, controller) {\n                if (chunk.type === \"text-delta\") {\n                    controller.enqueue(chunk.textDelta);\n                } else if (chunk.type === \"error\") {\n                    controller.error(chunk.error);\n                }\n            }\n        })));\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.teeStream());\n    }\n    toDataStreamInternal({ getErrorMessage: getErrorMessage5 = ()=>\"An error occurred.\", // mask error messages for safety by default\n    sendUsage = true } = {}) {\n        let aggregatedResponse = \"\";\n        const callbackTransformer = new TransformStream({\n            async transform (chunk, controller) {\n                controller.enqueue(chunk);\n                if (chunk.type === \"text-delta\") {\n                    aggregatedResponse += chunk.textDelta;\n                }\n            }\n        });\n        const streamPartsTransformer = new TransformStream({\n            transform: async (chunk, controller)=>{\n                const chunkType = chunk.type;\n                switch(chunkType){\n                    case \"text-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"text\", chunk.textDelta));\n                            break;\n                        }\n                    case \"tool-call-streaming-start\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_call_streaming_start\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName\n                            }));\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_call_delta\", {\n                                toolCallId: chunk.toolCallId,\n                                argsTextDelta: chunk.argsTextDelta\n                            }));\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_call\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                args: chunk.args\n                            }));\n                            break;\n                        }\n                    case \"tool-result\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"tool_result\", {\n                                toolCallId: chunk.toolCallId,\n                                result: chunk.result\n                            }));\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"error\", getErrorMessage5(chunk.error)));\n                            break;\n                        }\n                    case \"step-finish\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"finish_step\", {\n                                finishReason: chunk.finishReason,\n                                usage: sendUsage ? {\n                                    promptTokens: chunk.usage.promptTokens,\n                                    completionTokens: chunk.usage.completionTokens\n                                } : void 0,\n                                isContinued: chunk.isContinued\n                            }));\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"finish_message\", {\n                                finishReason: chunk.finishReason,\n                                usage: sendUsage ? {\n                                    promptTokens: chunk.usage.promptTokens,\n                                    completionTokens: chunk.usage.completionTokens\n                                } : void 0\n                            }));\n                            break;\n                        }\n                    default:\n                        {\n                            const exhaustiveCheck = chunkType;\n                            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n        return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamPartsTransformer);\n    }\n    pipeDataStreamToResponse(response, { status, statusText, headers, data, getErrorMessage: getErrorMessage5, sendUsage } = {}) {\n        writeToServerResponse({\n            response,\n            status,\n            statusText,\n            headers: prepareOutgoingHttpHeaders(headers, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            }),\n            stream: this.toDataStream({\n                data,\n                getErrorMessage: getErrorMessage5,\n                sendUsage\n            })\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())\n    toDataStream(options) {\n        const stream = this.toDataStreamInternal({\n            getErrorMessage: options == null ? void 0 : options.getErrorMessage,\n            sendUsage: options == null ? void 0 : options.sendUsage\n        }).pipeThrough(new TextEncoderStream());\n        return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;\n    }\n    mergeIntoDataStream(writer) {\n        writer.merge(this.toDataStreamInternal({\n            getErrorMessage: writer.onError\n        }));\n    }\n    toDataStreamResponse({ headers, status, statusText, data, getErrorMessage: getErrorMessage5, sendUsage } = {}) {\n        return new Response(this.toDataStream({\n            data,\n            getErrorMessage: getErrorMessage5,\n            sendUsage\n        }), {\n            status,\n            statusText,\n            headers: prepareResponseHeaders(headers, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            })\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a13;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a13 = init == null ? void 0 : init.status) != null ? _a13 : 200,\n            headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\n// core/generate-text/smooth-stream.ts\nfunction smoothStream({ delayInMs = 10, _internal: { delay: delay2 = delay } = {} } = {}) {\n    let buffer = \"\";\n    return ()=>new TransformStream({\n            async transform (chunk, controller) {\n                if (chunk.type === \"step-finish\") {\n                    if (buffer.length > 0) {\n                        controller.enqueue({\n                            type: \"text-delta\",\n                            textDelta: buffer\n                        });\n                        buffer = \"\";\n                    }\n                    controller.enqueue(chunk);\n                    return;\n                }\n                if (chunk.type !== \"text-delta\") {\n                    controller.enqueue(chunk);\n                    return;\n                }\n                buffer += chunk.textDelta;\n                while(buffer.match(/\\s/)){\n                    const whitespaceIndex = buffer.search(/\\s/);\n                    const word = buffer.slice(0, whitespaceIndex + 1);\n                    controller.enqueue({\n                        type: \"text-delta\",\n                        textDelta: word\n                    });\n                    buffer = buffer.slice(whitespaceIndex + 1);\n                    if (delayInMs > 0) {\n                        await delay2(delayInMs);\n                    }\n                }\n            }\n        });\n}\n// core/middleware/wrap-language-model.ts\nvar experimental_wrapLanguageModel = ({ model, middleware: { transformParams, wrapGenerate, wrapStream }, modelId, providerId })=>{\n    async function doTransform({ params, type }) {\n        return transformParams ? await transformParams({\n            params,\n            type\n        }) : params;\n    }\n    return {\n        specificationVersion: \"v1\",\n        provider: providerId != null ? providerId : model.provider,\n        modelId: modelId != null ? modelId : model.modelId,\n        defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n        supportsImageUrls: model.supportsImageUrls,\n        supportsUrl: model.supportsUrl,\n        supportsStructuredOutputs: model.supportsStructuredOutputs,\n        async doGenerate (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"generate\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            return wrapGenerate ? wrapGenerate({\n                doGenerate,\n                params: transformedParams,\n                model\n            }) : doGenerate();\n        },\n        async doStream (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"stream\"\n            });\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapStream ? wrapStream({\n                doStream,\n                params: transformedParams,\n                model\n            }) : doStream();\n        }\n    };\n};\n// core/registry/custom-provider.ts\n\nfunction experimental_customProvider({ languageModels, textEmbeddingModels, fallbackProvider }) {\n    return {\n        languageModel (modelId) {\n            if (languageModels != null && modelId in languageModels) {\n                return languageModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.languageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId,\n                modelType: \"languageModel\"\n            });\n        },\n        textEmbeddingModel (modelId) {\n            if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n                return textEmbeddingModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.textEmbeddingModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId,\n                modelType: \"textEmbeddingModel\"\n            });\n        }\n    };\n}\n// core/registry/no-such-provider-error.ts\n\nvar name12 = \"AI_NoSuchProviderError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError {\n    constructor({ modelId, modelType, providerId, availableProviders, message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})` }){\n        super({\n            errorName: name12,\n            modelId,\n            modelType,\n            message\n        });\n        this[_a12] = true;\n        this.providerId = providerId;\n        this.availableProviders = availableProviders;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker12);\n    }\n};\n_a12 = symbol12;\n// core/registry/provider-registry.ts\n\nfunction experimental_createProviderRegistry(providers) {\n    const registry = new DefaultProviderRegistry();\n    for (const [id, provider] of Object.entries(providers)){\n        registry.registerProvider({\n            id,\n            provider\n        });\n    }\n    return registry;\n}\nvar DefaultProviderRegistry = class {\n    constructor(){\n        this.providers = {};\n    }\n    registerProvider({ id, provider }) {\n        this.providers[id] = provider;\n    }\n    getProvider(id) {\n        const provider = this.providers[id];\n        if (provider == null) {\n            throw new NoSuchProviderError({\n                modelId: id,\n                modelType: \"languageModel\",\n                providerId: id,\n                availableProviders: Object.keys(this.providers)\n            });\n        }\n        return provider;\n    }\n    splitId(id, modelType) {\n        const index = id.indexOf(\":\");\n        if (index === -1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId: id,\n                modelType,\n                message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId:modelId\")`\n            });\n        }\n        return [\n            id.slice(0, index),\n            id.slice(index + 1)\n        ];\n    }\n    languageModel(id) {\n        var _a13, _b;\n        const [providerId, modelId] = this.splitId(id, \"languageModel\");\n        const model = (_b = (_a13 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a13, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId: id,\n                modelType: \"languageModel\"\n            });\n        }\n        return model;\n    }\n    textEmbeddingModel(id) {\n        var _a13;\n        const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n        const provider = this.getProvider(providerId);\n        const model = (_a13 = provider.textEmbeddingModel) == null ? void 0 : _a13.call(provider, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchModelError({\n                modelId: id,\n                modelType: \"textEmbeddingModel\"\n            });\n        }\n        return model;\n    }\n    /**\n   * @deprecated Use `textEmbeddingModel` instead.\n   */ textEmbedding(id) {\n        return this.textEmbeddingModel(id);\n    }\n};\n// core/tool/tool.ts\nfunction tool(tool2) {\n    return tool2;\n}\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n    if (vector1.length !== vector2.length) {\n        throw new Error(`Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`);\n    }\n    return dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2));\n}\nfunction dotProduct(vector1, vector2) {\n    return vector1.reduce((accumulator, value, index)=>accumulator + value * vector2[index], 0);\n}\nfunction magnitude(vector) {\n    return Math.sqrt(dotProduct(vector, vector));\n}\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n    const stream = new ReadableStream({\n        async start (controller) {\n            var _a13;\n            const textEncoder = new TextEncoder();\n            const sendMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"assistant_message\", message)));\n            };\n            const sendDataMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"data_message\", message)));\n            };\n            const sendError = (errorMessage)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"error\", errorMessage)));\n            };\n            const forwardStream = async (stream2)=>{\n                var _a14, _b;\n                let result = void 0;\n                for await (const value of stream2){\n                    switch(value.event){\n                        case \"thread.message.created\":\n                            {\n                                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"assistant_message\", {\n                                    id: value.data.id,\n                                    role: \"assistant\",\n                                    content: [\n                                        {\n                                            type: \"text\",\n                                            text: {\n                                                value: \"\"\n                                            }\n                                        }\n                                    ]\n                                })));\n                                break;\n                            }\n                        case \"thread.message.delta\":\n                            {\n                                const content = (_a14 = value.data.delta.content) == null ? void 0 : _a14[0];\n                                if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                                    controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"text\", content.text.value)));\n                                }\n                                break;\n                            }\n                        case \"thread.run.completed\":\n                        case \"thread.run.requires_action\":\n                            {\n                                result = value.data;\n                                break;\n                            }\n                    }\n                }\n                return result;\n            };\n            controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatAssistantStreamPart)(\"assistant_control_data\", {\n                threadId,\n                messageId\n            })));\n            try {\n                await process2({\n                    sendMessage,\n                    sendDataMessage,\n                    forwardStream\n                });\n            } catch (error) {\n                sendError((_a13 = error.message) != null ? _a13 : `${error}`);\n            } finally{\n                controller.close();\n            }\n        },\n        pull (controller) {},\n        cancel () {}\n    });\n    return new Response(stream, {\n        status: 200,\n        headers: {\n            \"Content-Type\": \"text/plain; charset=utf-8\"\n        }\n    });\n}\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n    mergeIntoDataStream: ()=>mergeIntoDataStream,\n    toDataStream: ()=>toDataStream,\n    toDataStreamResponse: ()=>toDataStreamResponse\n});\n\n// streams/stream-callbacks.ts\nfunction createCallbacksTransformer(callbacks = {}) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            controller.enqueue(textEncoder.encode(message));\n            aggregatedResponse += message;\n            if (callbacks.onToken) await callbacks.onToken(message);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\n// streams/langchain-adapter.ts\nfunction toDataStreamInternal(stream, callbacks) {\n    return stream.pipeThrough(new TransformStream({\n        transform: async (value, controller)=>{\n            var _a13;\n            if (typeof value === \"string\") {\n                controller.enqueue(value);\n                return;\n            }\n            if (\"event\" in value) {\n                if (value.event === \"on_chat_model_stream\") {\n                    forwardAIMessageChunk((_a13 = value.data) == null ? void 0 : _a13.chunk, controller);\n                }\n                return;\n            }\n            forwardAIMessageChunk(value, controller);\n        }\n    })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n        transform: async (chunk, controller)=>{\n            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"text\", chunk));\n        }\n    }));\n}\nfunction toDataStream(stream, callbacks) {\n    return toDataStreamInternal(stream, callbacks).pipeThrough(new TextEncoderStream());\n}\nfunction toDataStreamResponse(stream, options) {\n    var _a13;\n    const dataStream = toDataStreamInternal(stream, options == null ? void 0 : options.callbacks).pipeThrough(new TextEncoderStream());\n    const data = options == null ? void 0 : options.data;\n    const init = options == null ? void 0 : options.init;\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a13 = init == null ? void 0 : init.status) != null ? _a13 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction mergeIntoDataStream(stream, options) {\n    options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n    if (typeof chunk.content === \"string\") {\n        controller.enqueue(chunk.content);\n    } else {\n        const content = chunk.content;\n        for (const item of content){\n            if (item.type === \"text\") {\n                controller.enqueue(item.text);\n            }\n        }\n    }\n}\n// streams/llamaindex-adapter.ts\nvar llamaindex_adapter_exports = {};\n__export(llamaindex_adapter_exports, {\n    mergeIntoDataStream: ()=>mergeIntoDataStream2,\n    toDataStream: ()=>toDataStream2,\n    toDataStreamResponse: ()=>toDataStreamResponse2\n});\n\n\nfunction toDataStreamInternal2(stream, callbacks) {\n    const trimStart = trimStartOfStream();\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertAsyncIteratorToReadableStream)(stream[Symbol.asyncIterator]()).pipeThrough(new TransformStream({\n        async transform (message, controller) {\n            controller.enqueue(trimStart(message.delta));\n        }\n    })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n        transform: async (chunk, controller)=>{\n            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"text\", chunk));\n        }\n    }));\n}\nfunction toDataStream2(stream, callbacks) {\n    return toDataStreamInternal2(stream, callbacks).pipeThrough(new TextEncoderStream());\n}\nfunction toDataStreamResponse2(stream, options = {}) {\n    var _a13;\n    const { init, data, callbacks } = options;\n    const dataStream = toDataStreamInternal2(stream, callbacks).pipeThrough(new TextEncoderStream());\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a13 = init == null ? void 0 : init.status) != null ? _a13 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction mergeIntoDataStream2(stream, options) {\n    options.dataStream.merge(toDataStreamInternal2(stream, options.callbacks));\n}\nfunction trimStartOfStream() {\n    let isStreamStart = true;\n    return (text2)=>{\n        if (isStreamStart) {\n            text2 = text2.trimStart();\n            if (text2) isStreamStart = false;\n        }\n        return text2;\n    };\n}\n// streams/stream-data.ts\n\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n// streams/stream-data.ts\nvar StreamData = class {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this.controller = null;\n        this.isClosed = false;\n        this.warningTimeout = null;\n        const self = this;\n        this.stream = new ReadableStream({\n            start: async (controller)=>{\n                self.controller = controller;\n                if (true) {\n                    self.warningTimeout = setTimeout(()=>{\n                        console.warn(\"The data stream is hanging. Did you forget to close it with `data.close()`?\");\n                    }, HANGING_STREAM_WARNING_TIME_MS);\n                }\n            },\n            pull: (controller)=>{},\n            cancel: (reason)=>{\n                this.isClosed = true;\n            }\n        });\n    }\n    async close() {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.close();\n        this.isClosed = true;\n        if (this.warningTimeout) {\n            clearTimeout(this.warningTimeout);\n        }\n    }\n    append(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"data\", [\n            value\n        ])));\n    }\n    appendMessageAnnotation(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataStreamPart)(\"message_annotations\", [\n            value\n        ])));\n    }\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFVBQVVELElBQ2pCTCxVQUFVSSxRQUFRRSxRQUFRO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsT0FBTztRQUFFRSxZQUFZO0lBQUs7QUFDbkU7QUFFQSxtQkFBbUI7QUFRTztBQUN5QztBQUVuRSxnQkFBZ0I7QUFDOEI7QUFFOUMseUNBQXlDO0FBQ2U7QUFDeEQsU0FBU1ksaUJBQWlCLEVBQ3hCQyxPQUFPLEVBQ1BDLFVBQVUsSUFBTSxvQkFBb0IsRUFFckM7SUFDQyxJQUFJQztJQUNKLE1BQU1DLHdCQUF3QixFQUFFO0lBQ2hDLE1BQU1DLFNBQVMsSUFBSUMsZUFBZTtRQUNoQ0MsT0FBTUMsYUFBYTtZQUNqQkwsYUFBYUs7UUFDZjtJQUNGO0lBQ0EsU0FBU0MsWUFBWUMsSUFBSTtRQUN2QixJQUFJO1lBQ0ZQLFdBQVdRLE9BQU8sQ0FBQ0Q7UUFDckIsRUFBRSxPQUFPRSxPQUFPLENBQ2hCO0lBQ0Y7SUFDQSxJQUFJO1FBQ0YsTUFBTUMsU0FBU1osUUFBUTtZQUNyQmEsV0FBVUosSUFBSTtnQkFDWkQsWUFBWWxCLHNFQUFvQkEsQ0FBQyxRQUFRO29CQUFDbUI7aUJBQUs7WUFDakQ7WUFDQUssd0JBQXVCQyxVQUFVO2dCQUMvQlAsWUFBWWxCLHNFQUFvQkEsQ0FBQyx1QkFBdUI7b0JBQUN5QjtpQkFBVztZQUN0RTtZQUNBQyxPQUFNQyxTQUFTO2dCQUNiZCxzQkFBc0JlLElBQUksQ0FDeEIsQ0FBQztvQkFDQyxNQUFNQyxTQUFTRixVQUFVRyxTQUFTO29CQUNsQyxNQUFPLEtBQU07d0JBQ1gsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtB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bEI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDM0YsVUFBVSxFQUFFO1lBQ3BCLE1BQU0sSUFBSTJGLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUMzRixVQUFVLENBQUM2QixLQUFLO1FBQ3JCLElBQUksQ0FBQytjLFFBQVEsR0FBRztRQUNoQixJQUFJLElBQUksQ0FBQ21XLGNBQWMsRUFBRTtZQUN2QkksYUFBYSxJQUFJLENBQUNKLGNBQWM7UUFDbEM7SUFDRjtJQUNBSyxPQUFPaDBCLEtBQUssRUFBRTtRQUNaLElBQUksSUFBSSxDQUFDd2QsUUFBUSxFQUFFO1lBQ2pCLE1BQU0sSUFBSWpaLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDM0YsVUFBVSxFQUFFO1lBQ3BCLE1BQU0sSUFBSTJGLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUMzRixVQUFVLENBQUNRLE9BQU8sQ0FDckIsSUFBSSxDQUFDczBCLE9BQU8sQ0FBQy9CLE1BQU0sQ0FBQzRCLHNFQUFxQkEsQ0FBQyxRQUFRO1lBQUN2ekI7U0FBTTtJQUU3RDtJQUNBaTBCLHdCQUF3QmowQixLQUFLLEVBQUU7UUFDN0IsSUFBSSxJQUFJLENBQUN3ZCxRQUFRLEVBQUU7WUFDakIsTUFBTSxJQUFJalosTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUMzRixVQUFVLEVBQUU7WUFDcEIsTUFBTSxJQUFJMkYsTUFBTTtRQUNsQjtRQUNBLElBQUksQ0FBQzNGLFVBQVUsQ0FBQ1EsT0FBTyxDQUNyQixJQUFJLENBQUNzMEIsT0FBTyxDQUFDL0IsTUFBTSxDQUFDNEIsc0VBQXFCQSxDQUFDLHVCQUF1QjtZQUFDdnpCO1NBQU07SUFFNUU7QUFDRjtBQXVERSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NydC8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcz84MWViIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZTEzIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lMTMsIHsgZ2V0OiBhbGxbbmFtZTEzXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHN0cmVhbXMvaW5kZXgudHNcbmltcG9ydCB7XG4gIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQgYXMgZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydDIsXG4gIGZvcm1hdERhdGFTdHJlYW1QYXJ0IGFzIGZvcm1hdERhdGFTdHJlYW1QYXJ0NixcbiAgcGFyc2VBc3Npc3RhbnRTdHJlYW1QYXJ0LFxuICBwYXJzZURhdGFTdHJlYW1QYXJ0LFxuICBwcm9jZXNzRGF0YVN0cmVhbSxcbiAgcHJvY2Vzc1RleHRTdHJlYW1cbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmltcG9ydCB7IGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZDIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL2luZGV4LnRzXG5pbXBvcnQgeyBqc29uU2NoZW1hIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gY29yZS9kYXRhLXN0cmVhbS9jcmVhdGUtZGF0YS1zdHJlYW0udHNcbmltcG9ydCB7IGZvcm1hdERhdGFTdHJlYW1QYXJ0IH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZURhdGFTdHJlYW0oe1xuICBleGVjdXRlLFxuICBvbkVycm9yID0gKCkgPT4gXCJBbiBlcnJvciBvY2N1cnJlZC5cIlxuICAvLyBtYXNrIGVycm9yIG1lc3NhZ2VzIGZvciBzYWZldHkgYnkgZGVmYXVsdFxufSkge1xuICBsZXQgY29udHJvbGxlcjtcbiAgY29uc3Qgb25nb2luZ1N0cmVhbVByb21pc2VzID0gW107XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlckFyZykge1xuICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJBcmc7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gc2FmZUVucXVldWUoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBleGVjdXRlKHtcbiAgICAgIHdyaXRlRGF0YShkYXRhKSB7XG4gICAgICAgIHNhZmVFbnF1ZXVlKGZvcm1hdERhdGFTdHJlYW1QYXJ0KFwiZGF0YVwiLCBbZGF0YV0pKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZU1lc3NhZ2VBbm5vdGF0aW9uKGFubm90YXRpb24pIHtcbiAgICAgICAgc2FmZUVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIFthbm5vdGF0aW9uXSkpO1xuICAgICAgfSxcbiAgICAgIG1lcmdlKHN0cmVhbUFyZykge1xuICAgICAgICBvbmdvaW5nU3RyZWFtUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtQXJnLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIHNhZmVFbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgc2FmZUVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQoXCJlcnJvclwiLCBvbkVycm9yKGVycm9yKSkpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgb25FcnJvclxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5wdXNoKFxuICAgICAgICByZXN1bHQuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgc2FmZUVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQoXCJlcnJvclwiLCBvbkVycm9yKGVycm9yKSkpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgc2FmZUVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQoXCJlcnJvclwiLCBvbkVycm9yKGVycm9yKSkpO1xuICB9XG4gIGNvbnN0IHdhaXRGb3JTdHJlYW1zID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICB3aGlsZSAob25nb2luZ1N0cmVhbVByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXNvbHZlKCk7XG4gIH0pO1xuICB3YWl0Rm9yU3RyZWFtcy5maW5hbGx5KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gY29yZS91dGlsL3ByZXBhcmUtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhoZWFkZXJzLCB7XG4gIGNvbnRlbnRUeXBlLFxuICBkYXRhU3RyZWFtVmVyc2lvblxufSkge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30pO1xuICBpZiAoIXJlc3BvbnNlSGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICByZXNwb25zZUhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcbiAgfVxuICBpZiAoZGF0YVN0cmVhbVZlcnNpb24gIT09IHZvaWQgMCkge1xuICAgIHJlc3BvbnNlSGVhZGVycy5zZXQoXCJYLVZlcmNlbC1BSS1EYXRhLVN0cmVhbVwiLCBkYXRhU3RyZWFtVmVyc2lvbik7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlSGVhZGVycztcbn1cblxuLy8gY29yZS9kYXRhLXN0cmVhbS9jcmVhdGUtZGF0YS1zdHJlYW0tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZURhdGFTdHJlYW1SZXNwb25zZSh7XG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgZXhlY3V0ZSxcbiAgb25FcnJvclxufSkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgIGNyZWF0ZURhdGFTdHJlYW0oeyBleGVjdXRlLCBvbkVycm9yIH0pLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSxcbiAgICB7XG4gICAgICBzdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgICAgfSlcbiAgICB9XG4gICk7XG59XG5cbi8vIGNvcmUvdXRpbC9wcmVwYXJlLW91dGdvaW5nLWh0dHAtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaGVhZGVycywge1xuICBjb250ZW50VHlwZSxcbiAgZGF0YVN0cmVhbVZlcnNpb25cbn0pIHtcbiAgY29uc3Qgb3V0Z29pbmdIZWFkZXJzID0ge307XG4gIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgb3V0Z29pbmdIZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dGdvaW5nSGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PSBudWxsKSB7XG4gICAgb3V0Z29pbmdIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gY29udGVudFR5cGU7XG4gIH1cbiAgaWYgKGRhdGFTdHJlYW1WZXJzaW9uICE9PSB2b2lkIDApIHtcbiAgICBvdXRnb2luZ0hlYWRlcnNbXCJYLVZlcmNlbC1BSS1EYXRhLVN0cmVhbVwiXSA9IGRhdGFTdHJlYW1WZXJzaW9uO1xuICB9XG4gIHJldHVybiBvdXRnb2luZ0hlYWRlcnM7XG59XG5cbi8vIGNvcmUvdXRpbC93cml0ZS10by1zZXJ2ZXItcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbVxufSkge1xuICByZXNwb25zZS53cml0ZUhlYWQoc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDAsIHN0YXR1c1RleHQsIGhlYWRlcnMpO1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNwb25zZS5lbmQoKTtcbiAgICB9XG4gIH07XG4gIHJlYWQoKTtcbn1cblxuLy8gY29yZS9kYXRhLXN0cmVhbS9waXBlLWRhdGEtc3RyZWFtLXRvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBwaXBlRGF0YVN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBleGVjdXRlLFxuICBvbkVycm9yXG59KSB7XG4gIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgcmVzcG9uc2UsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaGVhZGVycywge1xuICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgIH0pLFxuICAgIHN0cmVhbTogY3JlYXRlRGF0YVN0cmVhbSh7IGV4ZWN1dGUsIG9uRXJyb3IgfSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVGV4dEVuY29kZXJTdHJlYW0oKVxuICAgIClcbiAgfSk7XG59XG5cbi8vIGVycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lID0gXCJBSV9JbnZhbGlkQXJndW1lbnRFcnJvclwiO1xudmFyIG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcmFtZXRlcixcbiAgICB2YWx1ZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lLFxuICAgICAgbWVzc2FnZTogYEludmFsaWQgYXJndW1lbnQgZm9yIHBhcmFtZXRlciAke3BhcmFtZXRlcn06ICR7bWVzc2FnZX1gXG4gICAgfSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xuXG4vLyB1dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSwgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gdXRpbC9kZWxheS50c1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoZGVsYXlJbk1zKSB7XG4gIHJldHVybiBkZWxheUluTXMgPT09IHZvaWQgMCA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlJbk1zKSk7XG59XG5cbi8vIHV0aWwvcmV0cnktZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUyID0gXCJBSV9SZXRyeUVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBSZXRyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlYXNvbixcbiAgICBlcnJvcnNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIyKTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHV0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID0gKHtcbiAgbWF4UmV0cmllcyA9IDIsXG4gIGluaXRpYWxEZWxheUluTXMgPSAyZTMsXG4gIGJhY2tvZmZGYWN0b3IgPSAyXG59ID0ge30pID0+IGFzeW5jIChmKSA9PiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0sIGVycm9ycyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcbiAgICBpZiAodHJ5TnVtYmVyID4gbWF4UmV0cmllcykge1xuICAgICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cy4gTGFzdCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgcmVhc29uOiBcIm1heFJldHJpZXNFeGNlZWRlZFwiLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIEFQSUNhbGxFcnJvci5pc0luc3RhbmNlKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXJldHJpZXMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXRyaWVzKHtcbiAgbWF4UmV0cmllc1xufSkge1xuICBpZiAobWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgPj0gMFwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWF4UmV0cmllc1Jlc3VsdCA9IG1heFJldHJpZXMgIT0gbnVsbCA/IG1heFJldHJpZXMgOiAyO1xuICByZXR1cm4ge1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNSZXN1bHQsXG4gICAgcmV0cnk6IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXM6IG1heFJldHJpZXNSZXN1bHQgfSlcbiAgfTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvYXNzZW1ibGUtb3BlcmF0aW9uLW5hbWUudHNcbmZ1bmN0aW9uIGFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gIG9wZXJhdGlvbklkLFxuICB0ZWxlbWV0cnlcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBzdGFuZGFyZGl6ZWQgb3BlcmF0aW9uIGFuZCByZXNvdXJjZSBuYW1lOlxuICAgIFwib3BlcmF0aW9uLm5hbWVcIjogYCR7b3BlcmF0aW9uSWR9JHsodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCkgIT0gbnVsbCA/IGAgJHt0ZWxlbWV0cnkuZnVuY3Rpb25JZH1gIDogXCJcIn1gLFxuICAgIFwicmVzb3VyY2UubmFtZVwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkLFxuICAgIC8vIGRldGFpbGVkLCBBSSBTREsgc3BlY2lmaWMgZGF0YTpcbiAgICBcImFpLm9wZXJhdGlvbklkXCI6IG9wZXJhdGlvbklkLFxuICAgIFwiYWkudGVsZW1ldHJ5LmZ1bmN0aW9uSWRcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZFxuICB9O1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtYmFzZS10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICBtb2RlbCxcbiAgc2V0dGluZ3MsXG4gIHRlbGVtZXRyeSxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2ExMztcbiAgcmV0dXJuIHtcbiAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIFwiYWkubW9kZWwuaWRcIjogbW9kZWwubW9kZWxJZCxcbiAgICAvLyBzZXR0aW5nczpcbiAgICAuLi5PYmplY3QuZW50cmllcyhzZXR0aW5ncykucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGF0dHJpYnV0ZXNbYGFpLnNldHRpbmdzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSksXG4gICAgLy8gYWRkIG1ldGFkYXRhIGFzIGF0dHJpYnV0ZXM6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoKF9hMTMgPSB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5tZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTMgOiB7fSkucmVkdWNlKFxuICAgICAgKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS50ZWxlbWV0cnkubWV0YWRhdGEuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9LFxuICAgICAge31cbiAgICApLFxuICAgIC8vIHJlcXVlc3QgaGVhZGVyc1xuICAgIC4uLk9iamVjdC5lbnRyaWVzKGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSkucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnJlcXVlc3QuaGVhZGVycy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pXG4gIH07XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuXG4vLyBjb3JlL3RlbGVtZXRyeS9ub29wLXRyYWNlci50c1xudmFyIG5vb3BUcmFjZXIgPSB7XG4gIHN0YXJ0U3BhbigpIHtcbiAgICByZXR1cm4gbm9vcFNwYW47XG4gIH0sXG4gIHN0YXJ0QWN0aXZlU3BhbihuYW1lMTMsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzEobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzIobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzMobm9vcFNwYW4pO1xuICAgIH1cbiAgfVxufTtcbnZhciBub29wU3BhbiA9IHtcbiAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuQ29udGV4dDtcbiAgfSxcbiAgc2V0QXR0cmlidXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGluaygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGlua3MoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldFN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdXBkYXRlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlY29yZEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub29wU3BhbkNvbnRleHQgPSB7XG4gIHRyYWNlSWQ6IFwiXCIsXG4gIHNwYW5JZDogXCJcIixcbiAgdHJhY2VGbGFnczogMFxufTtcblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xuZnVuY3Rpb24gZ2V0VHJhY2VyKHtcbiAgaXNFbmFibGVkID0gZmFsc2UsXG4gIHRyYWNlclxufSA9IHt9KSB7XG4gIGlmICghaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIG5vb3BUcmFjZXI7XG4gIH1cbiAgaWYgKHRyYWNlcikge1xuICAgIHJldHVybiB0cmFjZXI7XG4gIH1cbiAgcmV0dXJuIHRyYWNlLmdldFRyYWNlcihcImFpXCIpO1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9yZWNvcmQtc3Bhbi50c1xuaW1wb3J0IHsgU3BhblN0YXR1c0NvZGUgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5mdW5jdGlvbiByZWNvcmRTcGFuKHtcbiAgbmFtZTogbmFtZTEzLFxuICB0cmFjZXIsXG4gIGF0dHJpYnV0ZXMsXG4gIGZuLFxuICBlbmRXaGVuRG9uZSA9IHRydWVcbn0pIHtcbiAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZTEzLCB7IGF0dHJpYnV0ZXMgfSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oc3Bhbik7XG4gICAgICBpZiAoZW5kV2hlbkRvbmUpIHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oe1xuICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvc2VsZWN0LXRlbGVtZXRyeS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgdGVsZW1ldHJ5LFxuICBhdHRyaWJ1dGVzXG59KSB7XG4gIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykucmVkdWNlKChhdHRyaWJ1dGVzMiwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImlucHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmlucHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkSW5wdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuaW5wdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwib3V0cHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLm91dHB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZE91dHB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5vdXRwdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHZhbHVlIH07XG4gIH0sIHt9KTtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWQoe1xuICBtb2RlbCxcbiAgdmFsdWUsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnlcbn0pIHtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnIH0pO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLnZhbHVlXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgeyBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7IGlucHV0OiAoKSA9PiBbSlNPTi5zdHJpbmdpZnkodmFsdWUpXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmcyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzWzBdO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExMyA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTEzIDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmczKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmczKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nOiBlbWJlZGRpbmcyLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB1c2FnZTIsXG4gICAgICAgICAgICAgICAgcmF3UmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZFJlc3VsdCh7IHZhbHVlLCBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IG9wdGlvbnMucmF3UmVzcG9uc2U7XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9zcGxpdC1hcnJheS50c1xuZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheSwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC1tYW55LnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZE1hbnkoe1xuICBtb2RlbCxcbiAgdmFsdWVzLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHsgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyB9KTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueVwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IG1heEVtYmVkZGluZ3NQZXJDYWxsID0gbW9kZWwubWF4RW1iZWRkaW5nc1BlckNhbGw7XG4gICAgICBpZiAobWF4RW1iZWRkaW5nc1BlckNhbGwgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZSB9ID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMyA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMTMgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExMyA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MzLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZTIudG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczMsIHVzYWdlOiB1c2FnZTIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoeyB2YWx1ZXMsIGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZSB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlQ2h1bmtzID0gc3BsaXRBcnJheSh2YWx1ZXMsIG1heEVtYmVkZGluZ3NQZXJDYWxsKTtcbiAgICAgIGNvbnN0IGVtYmVkZGluZ3MgPSBbXTtcbiAgICAgIGxldCB0b2tlbnMgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiB2YWx1ZUNodW5rcykge1xuICAgICAgICBjb25zdCB7IGVtYmVkZGluZ3M6IHJlc3BvbnNlRW1iZWRkaW5ncywgdXNhZ2UgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNodW5rLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogY2h1bmssXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczIgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTEzID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTMgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLCB1c2FnZTogdXNhZ2UyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbWJlZGRpbmdzLnB1c2goLi4ucmVzcG9uc2VFbWJlZGRpbmdzKTtcbiAgICAgICAgdG9rZW5zICs9IHVzYWdlLnRva2VucztcbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB0b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBlbWJlZGRpbmdzLFxuICAgICAgICB1c2FnZTogeyB0b2tlbnMgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRNYW55UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLmVtYmVkZGluZ3MgPSBvcHRpb25zLmVtYmVkZGluZ3M7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtaW1hZ2UvZ2VuZXJhdGUtaW1hZ2UudHNcbmltcG9ydCB7IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZSh7XG4gIG1vZGVsLFxuICBwcm9tcHQsXG4gIG4sXG4gIHNpemUsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgY29uc3QgeyByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnIH0pO1xuICBjb25zdCB7IGltYWdlcyB9ID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICBwcm9tcHQsXG4gICAgICBuOiBuICE9IG51bGwgPyBuIDogMSxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNpemUsXG4gICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyT3B0aW9ucyAhPSBudWxsID8gcHJvdmlkZXJPcHRpb25zIDoge31cbiAgICB9KVxuICApO1xuICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZUltYWdlUmVzdWx0KHsgYmFzZTY0SW1hZ2VzOiBpbWFnZXMgfSk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlSW1hZ2VSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmltYWdlcyA9IG9wdGlvbnMuYmFzZTY0SW1hZ2VzLm1hcCgoYmFzZTY0KSA9PiAoe1xuICAgICAgYmFzZTY0LFxuICAgICAgZ2V0IHVpbnQ4QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KHRoaXMuYmFzZTY0KTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlc1swXTtcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciwgc2FmZVBhcnNlSlNPTiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGVycm9ycy9uby1vYmplY3QtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMyA9IFwiQUlfTm9PYmplY3RHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2wzID0gU3ltYm9sLmZvcihtYXJrZXIzKTtcbnZhciBfYTM7XG52YXIgTm9PYmplY3RHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gb2JqZWN0IGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICB0ZXh0OiB0ZXh0MixcbiAgICByZXNwb25zZSxcbiAgICB1c2FnZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0MjtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyB1dGlsL2Rvd25sb2FkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNCA9IFwiQUlfRG93bmxvYWRFcnJvclwiO1xudmFyIG1hcmtlcjQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w0ID0gU3ltYm9sLmZvcihtYXJrZXI0KTtcbnZhciBfYTQ7XG52YXIgRG93bmxvYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gY2F1c2UgPT0gbnVsbCA/IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke3N0YXR1c0NvZGV9ICR7c3RhdHVzVGV4dH1gIDogYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7Y2F1c2V9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTRdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxufTtcbl9hNCA9IHN5bWJvbDQ7XG5cbi8vIHV0aWwvZG93bmxvYWQudHNcbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHtcbiAgdXJsLFxuICBmZXRjaEltcGxlbWVudGF0aW9uID0gZmV0Y2hcbn0pIHtcbiAgdmFyIF9hMTM7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoSW1wbGVtZW50YXRpb24odXJsVGV4dCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICB1cmw6IHVybFRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgIG1pbWVUeXBlOiAoX2ExMyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSAhPSBudWxsID8gX2ExMyA6IHZvaWQgMFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKERvd25sb2FkRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7IHVybDogdXJsVGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5cbi8vIGNvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHNcbnZhciBtaW1lVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvZ2lmXCIsIGJ5dGVzOiBbNzEsIDczLCA3MF0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9wbmdcIiwgYnl0ZXM6IFsxMzcsIDgwLCA3OCwgNzFdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvanBlZ1wiLCBieXRlczogWzI1NSwgMjE2XSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3dlYnBcIiwgYnl0ZXM6IFs4MiwgNzMsIDcwLCA3MF0gfVxuXTtcbmZ1bmN0aW9uIGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2UpIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChpbWFnZS5sZW5ndGggPj0gYnl0ZXMubGVuZ3RoICYmIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKSkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTIsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9wcm9tcHQvaW52YWxpZC1kYXRhLWNvbnRlbnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU1ID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZERhdGFDb250ZW50RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I1IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E1XSA9IHRydWU7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xudmFyIGRhdGFDb250ZW50U2NoZW1hID0gei51bmlvbihbXG4gIHouc3RyaW5nKCksXG4gIHouaW5zdGFuY2VvZihVaW50OEFycmF5KSxcbiAgei5pbnN0YW5jZW9mKEFycmF5QnVmZmVyKSxcbiAgei5jdXN0b20oXG4gICAgLy8gQnVmZmVyIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gc29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBDbG91ZEZsYXJlOlxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hMTMsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYTEzID0gZ2xvYmFsVGhpcy5CdWZmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTEzLmlzQnVmZmVyKHZhbHVlKSkgIT0gbnVsbCA/IF9iIDogZmFsc2U7XG4gICAgfSxcbiAgICB7IG1lc3NhZ2U6IFwiTXVzdCBiZSBhIEJ1ZmZlclwiIH1cbiAgKVxuXSk7XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoY29udGVudCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkyKGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgZGF0YSBjb250ZW50LiBDb250ZW50IHN0cmluZyBpcyBub3QgYSBiYXNlNjQtZW5jb2RlZCBtZWRpYS5cIixcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb1RleHQodWludDhBcnJheSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludDhBcnJheSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZGVjb2RpbmcgVWludDhBcnJheSB0byB0ZXh0XCIpO1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I2IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNiA9IFwiQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3JcIjtcbnZhciBtYXJrZXI2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU2fWA7XG52YXIgc3ltYm9sNiA9IFN5bWJvbC5mb3IobWFya2VyNik7XG52YXIgX2E2O1xudmFyIEludmFsaWRNZXNzYWdlUm9sZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU2LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjYpO1xuICB9XG59O1xuX2E2ID0gc3ltYm9sNjtcblxuLy8gY29yZS9wcm9tcHQvc3BsaXQtZGF0YS11cmwudHNcbmZ1bmN0aW9uIHNwbGl0RGF0YVVybChkYXRhVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWltZVR5cGU6IGhlYWRlci5zcGxpdChcIjtcIilbMF0uc3BsaXQoXCI6XCIpWzFdLFxuICAgICAgYmFzZTY0Q29udGVudFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbWVUeXBlOiB2b2lkIDAsXG4gICAgICBiYXNlNjRDb250ZW50OiB2b2lkIDBcbiAgICB9O1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgcHJvbXB0LFxuICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzID0gdHJ1ZSxcbiAgbW9kZWxTdXBwb3J0c1VybCA9ICgpID0+IGZhbHNlLFxuICBkb3dubG9hZEltcGxlbWVudGF0aW9uID0gZG93bmxvYWRcbn0pIHtcbiAgY29uc3QgZG93bmxvYWRlZEFzc2V0cyA9IGF3YWl0IGRvd25sb2FkQXNzZXRzKFxuICAgIHByb21wdC5tZXNzYWdlcyxcbiAgICBkb3dubG9hZEltcGxlbWVudGF0aW9uLFxuICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMsXG4gICAgbW9kZWxTdXBwb3J0c1VybFxuICApO1xuICByZXR1cm4gW1xuICAgIC4uLnByb21wdC5zeXN0ZW0gIT0gbnVsbCA/IFt7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfV0gOiBbXSxcbiAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKFxuICAgICAgKG1lc3NhZ2UpID0+IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKG1lc3NhZ2UsIGRvd25sb2FkZWRBc3NldHMpXG4gICAgKVxuICBdO1xufVxuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cykge1xuICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlO1xuICBzd2l0Y2ggKHJvbGUpIHtcbiAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKChwYXJ0KSA9PiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQocGFydCwgZG93bmxvYWRlZEFzc2V0cykpLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCIpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHRleHQgcGFydHM6XG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiXG4gICAgICAgICkubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSwgLi4ucmVzdCB9ID0gcGFydDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKChwYXJ0KSA9PiAoe1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgcmVzdWx0OiBwYXJ0LnJlc3VsdCxcbiAgICAgICAgICBjb250ZW50OiBwYXJ0LmV4cGVyaW1lbnRhbF9jb250ZW50LFxuICAgICAgICAgIGlzRXJyb3I6IHBhcnQuaXNFcnJvcixcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH0pKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJvbGU7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IoeyByb2xlOiBfZXhoYXVzdGl2ZUNoZWNrIH0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRBc3NldHMobWVzc2FnZXMsIGRvd25sb2FkSW1wbGVtZW50YXRpb24sIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMsIG1vZGVsU3VwcG9ydHNVcmwpIHtcbiAgY29uc3QgdXJscyA9IG1lc3NhZ2VzLmZpbHRlcigobWVzc2FnZSkgPT4gbWVzc2FnZS5yb2xlID09PSBcInVzZXJcIikubWFwKChtZXNzYWdlKSA9PiBtZXNzYWdlLmNvbnRlbnQpLmZpbHRlcihcbiAgICAoY29udGVudCkgPT4gQXJyYXkuaXNBcnJheShjb250ZW50KVxuICApLmZsYXQoKS5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiIHx8IHBhcnQudHlwZSA9PT0gXCJmaWxlXCJcbiAgKS5maWx0ZXIoXG4gICAgKHBhcnQpID0+ICEocGFydC50eXBlID09PSBcImltYWdlXCIgJiYgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyA9PT0gdHJ1ZSlcbiAgKS5tYXAoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiID8gcGFydC5pbWFnZSA6IHBhcnQuZGF0YSkubWFwKFxuICAgIChwYXJ0KSA9PiAoXG4gICAgICAvLyBzdXBwb3J0IHN0cmluZyB1cmxzOlxuICAgICAgdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIgJiYgKHBhcnQuc3RhcnRzV2l0aChcImh0dHA6XCIpIHx8IHBhcnQuc3RhcnRzV2l0aChcImh0dHBzOlwiKSkgPyBuZXcgVVJMKHBhcnQpIDogcGFydFxuICAgIClcbiAgKS5maWx0ZXIoKGltYWdlKSA9PiBpbWFnZSBpbnN0YW5jZW9mIFVSTCkuZmlsdGVyKCh1cmwpID0+ICFtb2RlbFN1cHBvcnRzVXJsKHVybCkpO1xuICBjb25zdCBkb3dubG9hZGVkSW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdXJscy5tYXAoYXN5bmMgKHVybCkgPT4gKHtcbiAgICAgIHVybCxcbiAgICAgIGRhdGE6IGF3YWl0IGRvd25sb2FkSW1wbGVtZW50YXRpb24oeyB1cmwgfSlcbiAgICB9KSlcbiAgKTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBkb3dubG9hZGVkSW1hZ2VzLm1hcCgoeyB1cmwsIGRhdGEgfSkgPT4gW3VybC50b1N0cmluZygpLCBkYXRhXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydChwYXJ0LCBkb3dubG9hZGVkQXNzZXRzKSB7XG4gIHZhciBfYTEzO1xuICBpZiAocGFydC50eXBlID09PSBcInRleHRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICB9O1xuICB9XG4gIGxldCBtaW1lVHlwZSA9IHBhcnQubWltZVR5cGU7XG4gIGxldCBkYXRhO1xuICBsZXQgY29udGVudDtcbiAgbGV0IG5vcm1hbGl6ZWREYXRhO1xuICBjb25zdCB0eXBlID0gcGFydC50eXBlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGRhdGEgPSBwYXJ0LmltYWdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIGRhdGEgPSBwYXJ0LmRhdGE7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnRlbnQgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IG5ldyBVUkwoZGF0YSkgOiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnRlbnQgPSBkYXRhO1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVVJMKSB7XG4gICAgaWYgKGNvbnRlbnQucHJvdG9jb2wgPT09IFwiZGF0YTpcIikge1xuICAgICAgY29uc3QgeyBtaW1lVHlwZTogZGF0YVVybE1pbWVUeXBlLCBiYXNlNjRDb250ZW50IH0gPSBzcGxpdERhdGFVcmwoXG4gICAgICAgIGNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgKTtcbiAgICAgIGlmIChkYXRhVXJsTWltZVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdCBpbiBwYXJ0ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIG1pbWVUeXBlID0gZGF0YVVybE1pbWVUeXBlO1xuICAgICAgbm9ybWFsaXplZERhdGEgPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRvd25sb2FkZWRGaWxlID0gZG93bmxvYWRlZEFzc2V0c1tjb250ZW50LnRvU3RyaW5nKCldO1xuICAgICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICAgIG5vcm1hbGl6ZWREYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgICAgbWltZVR5cGUgIT0gbnVsbCA/IG1pbWVUeXBlIDogbWltZVR5cGUgPSBkb3dubG9hZGVkRmlsZS5taW1lVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWREYXRhID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9ybWFsaXplZERhdGEgPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgIGlmIChub3JtYWxpemVkRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbWltZVR5cGUgPSAoX2ExMyA9IGRldGVjdEltYWdlTWltZVR5cGUobm9ybWFsaXplZERhdGEpKSAhPSBudWxsID8gX2ExMyA6IG1pbWVUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICBpbWFnZTogbm9ybWFsaXplZERhdGEsXG4gICAgICAgIG1pbWVUeXBlLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICBpZiAobWltZVR5cGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pbWUgdHlwZSBpcyBtaXNzaW5nIGZvciBmaWxlIHBhcnRgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBkYXRhOiBub3JtYWxpemVkRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhub3JtYWxpemVkRGF0YSkgOiBub3JtYWxpemVkRGF0YSxcbiAgICAgICAgbWltZVR5cGUsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50c1xuZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHRvcEssXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc3RvcFNlcXVlbmNlcyxcbiAgc2VlZFxufSkge1xuICBpZiAobWF4VG9rZW5zICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4VG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4VG9rZW5zIG11c3QgYmUgPj0gMVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidGVtcGVyYXR1cmVcIixcbiAgICAgICAgdmFsdWU6IHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiBcInRlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BQXCIsXG4gICAgICAgIHZhbHVlOiB0b3BQLFxuICAgICAgICBtZXNzYWdlOiBcInRvcFAgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcEsgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wSyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcEtcIixcbiAgICAgICAgdmFsdWU6IHRvcEssXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wSyBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByZXNlbmNlUGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInByZXNlbmNlUGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcInByZXNlbmNlUGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBmcmVxdWVuY3lQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZnJlcXVlbmN5UGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJmcmVxdWVuY3lQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VlZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzZWVkXCIsXG4gICAgICAgIHZhbHVlOiBzZWVkLFxuICAgICAgICBtZXNzYWdlOiBcInNlZWQgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgIT0gbnVsbCA/IHRlbXBlcmF0dXJlIDogMCxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczogc3RvcFNlcXVlbmNlcyAhPSBudWxsICYmIHN0b3BTZXF1ZW5jZXMubGVuZ3RoID4gMCA/IHN0b3BTZXF1ZW5jZXMgOiB2b2lkIDAsXG4gICAgc2VlZFxuICB9O1xufVxuXG4vLyBjb3JlL3Byb21wdC9zdGFuZGFyZGl6ZS1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBzYWZlVmFsaWRhdGVUeXBlcyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo3IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL2pzb24tdmFsdWUudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG52YXIganNvblZhbHVlU2NoZW1hID0gejIubGF6eShcbiAgKCkgPT4gejIudW5pb24oW1xuICAgIHoyLm51bGwoKSxcbiAgICB6Mi5zdHJpbmcoKSxcbiAgICB6Mi5udW1iZXIoKSxcbiAgICB6Mi5ib29sZWFuKCksXG4gICAgejIucmVjb3JkKHoyLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpLFxuICAgIHoyLmFycmF5KGpzb25WYWx1ZVNjaGVtYSlcbiAgXSlcbik7XG5cbi8vIGNvcmUvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbnZhciBwcm92aWRlck1ldGFkYXRhU2NoZW1hID0gejMucmVjb3JkKFxuICB6My5zdHJpbmcoKSxcbiAgejMucmVjb3JkKHozLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejUgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L3Rvb2wtcmVzdWx0LWNvbnRlbnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kXCI7XG52YXIgdG9vbFJlc3VsdENvbnRlbnRTY2hlbWEgPSB6NC5hcnJheShcbiAgejQudW5pb24oW1xuICAgIHo0Lm9iamVjdCh7IHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLCB0ZXh0OiB6NC5zdHJpbmcoKSB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImltYWdlXCIpLFxuICAgICAgZGF0YTogejQuc3RyaW5nKCksXG4gICAgICBtaW1lVHlwZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgIH0pXG4gIF0pXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbnZhciB0ZXh0UGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICB0ZXh0OiB6NS5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgaW1hZ2VQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcImltYWdlXCIpLFxuICBpbWFnZTogejUudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6NS5pbnN0YW5jZW9mKFVSTCldKSxcbiAgbWltZVR5cGU6IHo1LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGZpbGVQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcImZpbGVcIiksXG4gIGRhdGE6IHo1LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejUuaW5zdGFuY2VvZihVUkwpXSksXG4gIG1pbWVUeXBlOiB6NS5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbENhbGxQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcInRvb2wtY2FsbFwiKSxcbiAgdG9vbENhbGxJZDogejUuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NS5zdHJpbmcoKSxcbiAgYXJnczogejUudW5rbm93bigpXG59KTtcbnZhciB0b29sUmVzdWx0UGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJ0b29sLXJlc3VsdFwiKSxcbiAgdG9vbENhbGxJZDogejUuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NS5zdHJpbmcoKSxcbiAgcmVzdWx0OiB6NS51bmtub3duKCksXG4gIGNvbnRlbnQ6IHRvb2xSZXN1bHRDb250ZW50U2NoZW1hLm9wdGlvbmFsKCksXG4gIGlzRXJyb3I6IHo1LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcblxuLy8gY29yZS9wcm9tcHQvbWVzc2FnZS50c1xudmFyIGNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgcm9sZTogejYubGl0ZXJhbChcInN5c3RlbVwiKSxcbiAgY29udGVudDogejYuc3RyaW5nKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6Ni51bmlvbihbXG4gICAgejYuc3RyaW5nKCksXG4gICAgejYuYXJyYXkoejYudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlQXNzaXN0YW50TWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJhc3Npc3RhbnRcIiksXG4gIGNvbnRlbnQ6IHo2LnVuaW9uKFtcbiAgICB6Ni5zdHJpbmcoKSxcbiAgICB6Ni5hcnJheSh6Ni51bmlvbihbdGV4dFBhcnRTY2hlbWEsIHRvb2xDYWxsUGFydFNjaGVtYV0pKVxuICBdKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZVRvb2xNZXNzYWdlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgcm9sZTogejYubGl0ZXJhbChcInRvb2xcIiksXG4gIGNvbnRlbnQ6IHo2LmFycmF5KHRvb2xSZXN1bHRQYXJ0U2NoZW1hKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZU1lc3NhZ2VTY2hlbWEgPSB6Ni51bmlvbihbXG4gIGNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hLFxuICBjb3JlVXNlck1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hLFxuICBjb3JlVG9vbE1lc3NhZ2VTY2hlbWFcbl0pO1xuXG4vLyBjb3JlL3Byb21wdC9kZXRlY3QtcHJvbXB0LXR5cGUudHNcbmZ1bmN0aW9uIGRldGVjdFByb21wdFR5cGUocHJvbXB0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9tcHQpKSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxuICBpZiAocHJvbXB0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIm1lc3NhZ2VzXCI7XG4gIH1cbiAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gcHJvbXB0Lm1hcChkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzKTtcbiAgaWYgKGNoYXJhY3RlcmlzdGljcy5zb21lKChjKSA9PiBjID09PSBcImhhcy11aS1zcGVjaWZpYy1wYXJ0c1wiKSkge1xuICAgIHJldHVybiBcInVpLW1lc3NhZ2VzXCI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyaXN0aWNzLmV2ZXJ5KFxuICAgIChjKSA9PiBjID09PSBcImhhcy1jb3JlLXNwZWNpZmljLXBhcnRzXCIgfHwgYyA9PT0gXCJtZXNzYWdlXCJcbiAgKSkge1xuICAgIHJldHVybiBcIm1lc3NhZ2VzXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZWN0U2luZ2xlTWVzc2FnZUNoYXJhY3RlcmlzdGljcyhtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIChtZXNzYWdlLnJvbGUgPT09IFwiZnVuY3Rpb25cIiB8fCAvLyBVSS1vbmx5IHJvbGVcbiAgbWVzc2FnZS5yb2xlID09PSBcImRhdGFcIiB8fCAvLyBVSS1vbmx5IHJvbGVcbiAgXCJ0b29sSW52b2NhdGlvbnNcIiBpbiBtZXNzYWdlIHx8IC8vIFVJLXNwZWNpZmljIGZpZWxkXG4gIFwiZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzXCIgaW4gbWVzc2FnZSkpIHtcbiAgICByZXR1cm4gXCJoYXMtdWktc3BlY2lmaWMtcGFydHNcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwiY29udGVudFwiIGluIG1lc3NhZ2UgJiYgKEFycmF5LmlzQXJyYXkobWVzc2FnZS5jb250ZW50KSB8fCAvLyBDb3JlIG1lc3NhZ2VzIGNhbiBoYXZlIGFycmF5IGNvbnRlbnRcbiAgXCJleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVwiIGluIG1lc3NhZ2UpKSB7XG4gICAgcmV0dXJuIFwiaGFzLWNvcmUtc3BlY2lmaWMtcGFydHNcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwicm9sZVwiIGluIG1lc3NhZ2UgJiYgXCJjb250ZW50XCIgaW4gbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiICYmIFtcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCJdLmluY2x1ZGVzKG1lc3NhZ2Uucm9sZSkpIHtcbiAgICByZXR1cm4gXCJtZXNzYWdlXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9hdHRhY2htZW50cy10by1wYXJ0cy50c1xuZnVuY3Rpb24gYXR0YWNobWVudHNUb1BhcnRzKGF0dGFjaG1lbnRzKSB7XG4gIHZhciBfYTEzLCBfYiwgX2M7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAoY29uc3QgYXR0YWNobWVudCBvZiBhdHRhY2htZW50cykge1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBVUkwoYXR0YWNobWVudC51cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke2F0dGFjaG1lbnQudXJsfWApO1xuICAgIH1cbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgY2FzZSBcImh0dHA6XCI6XG4gICAgICBjYXNlIFwiaHR0cHM6XCI6IHtcbiAgICAgICAgaWYgKChfYTEzID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTMuc3RhcnRzV2l0aChcImltYWdlL1wiKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiBcImltYWdlXCIsIGltYWdlOiB1cmwgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFhdHRhY2htZW50LmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSWYgdGhlIGF0dGFjaG1lbnQgaXMgbm90IGFuIGltYWdlLCBpdCBtdXN0IHNwZWNpZnkgYSBjb250ZW50IHR5cGVcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGF0YTpcIjoge1xuICAgICAgICBsZXQgaGVhZGVyO1xuICAgICAgICBsZXQgYmFzZTY0Q29udGVudDtcbiAgICAgICAgbGV0IG1pbWVUeXBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gYXR0YWNobWVudC51cmwuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgIG1pbWVUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGRhdGEgVVJMOiAke2F0dGFjaG1lbnQudXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQ6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfYiA9IGF0dGFjaG1lbnQuY29udGVudFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICBpbWFnZTogY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKF9jID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0YXJ0c1dpdGgoXCJ0ZXh0L1wiKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBjb252ZXJ0VWludDhBcnJheVRvVGV4dChcbiAgICAgICAgICAgICAgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFhdHRhY2htZW50LmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSWYgdGhlIGF0dGFjaG1lbnQgaXMgbm90IGFuIGltYWdlIG9yIHRleHQsIGl0IG11c3Qgc3BlY2lmeSBhIGNvbnRlbnQgdHlwZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZGF0YTogYmFzZTY0Q29udGVudCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgVVJMIHByb3RvY29sOiAke3VybC5wcm90b2NvbH1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLWNvbnZlcnNpb24tZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU3ID0gXCJBSV9NZXNzYWdlQ29udmVyc2lvbkVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBNZXNzYWdlQ29udmVyc2lvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvcmlnaW5hbE1lc3NhZ2UsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I3Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWNvcmUtbWVzc2FnZXMudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyhtZXNzYWdlcywgb3B0aW9ucykge1xuICB2YXIgX2ExMztcbiAgY29uc3QgdG9vbHMgPSAoX2ExMyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpICE9IG51bGwgPyBfYTEzIDoge307XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBjb25zdCB7IHJvbGUsIGNvbnRlbnQsIHRvb2xJbnZvY2F0aW9ucywgZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzIH0gPSBtZXNzYWdlO1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzID8gW1xuICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgLi4uYXR0YWNobWVudHNUb1BhcnRzKGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cylcbiAgICAgICAgICBdIDogY29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goeyByb2xlOiBcImFzc2lzdGFudFwiLCBjb250ZW50IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgIC4uLnRvb2xJbnZvY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICh7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCBhcmdzIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgY29udGVudDogdG9vbEludm9jYXRpb25zLm1hcCgodG9vbEludm9jYXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmICghKFwicmVzdWx0XCIgaW4gdG9vbEludm9jYXRpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBNZXNzYWdlQ29udmVyc2lvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJUb29sSW52b2NhdGlvbiBtdXN0IGhhdmUgYSByZXN1bHQ6IFwiICsgSlNPTi5zdHJpbmdpZnkodG9vbEludm9jYXRpb24pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgcmVzdWx0IH0gPSB0b29sSW52b2NhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIHJlc3VsdDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQocmVzdWx0KSxcbiAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRlbnQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHJlc3VsdClcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGF0YVwiOiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3JlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQoe1xuICBwcm9tcHQsXG4gIHRvb2xzXG59KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwgJiYgdHlwZW9mIHByb21wdC5zeXN0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmdcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByb21wdC5wcm9tcHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG11c3QgYmUgYSBzdHJpbmdcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByb21wdFwiLFxuICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHByb21wdC5wcm9tcHRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cbiAgaWYgKHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgY29uc3QgcHJvbXB0VHlwZSA9IGRldGVjdFByb21wdFR5cGUocHJvbXB0Lm1lc3NhZ2VzKTtcbiAgICBpZiAocHJvbXB0VHlwZSA9PT0gXCJvdGhlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlOiBcIm1lc3NhZ2VzIG11c3QgYmUgYW4gYXJyYXkgb2YgQ29yZU1lc3NhZ2Ugb3IgVUlNZXNzYWdlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHByb21wdFR5cGUgPT09IFwidWktbWVzc2FnZXNcIiA/IGNvbnZlcnRUb0NvcmVNZXNzYWdlcyhwcm9tcHQubWVzc2FnZXMsIHtcbiAgICAgIHRvb2xzXG4gICAgfSkgOiBwcm9tcHQubWVzc2FnZXM7XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgIHNjaGVtYTogejcuYXJyYXkoY29yZU1lc3NhZ2VTY2hlbWEpXG4gICAgfSk7XG4gICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBDb3JlTWVzc2FnZSBvciBVSU1lc3NhZ2VcIixcbiAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtZXNzYWdlc1wiLFxuICAgICAgbWVzc2FnZXMsXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xufVxuXG4vLyBjb3JlL3R5cGVzL3VzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2Uoe1xuICBwcm9tcHRUb2tlbnMsXG4gIGNvbXBsZXRpb25Ub2tlbnNcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogcHJvbXB0VG9rZW5zICsgY29tcGxldGlvblRva2Vuc1xuICB9O1xufVxuZnVuY3Rpb24gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlMSwgdXNhZ2UyKSB7XG4gIHJldHVybiB7XG4gICAgcHJvbXB0VG9rZW5zOiB1c2FnZTEucHJvbXB0VG9rZW5zICsgdXNhZ2UyLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZTEuY29tcGxldGlvblRva2VucyArIHVzYWdlMi5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZTEudG90YWxUb2tlbnMgKyB1c2FnZTIudG90YWxUb2tlbnNcbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvaW5qZWN0LWpzb24taW5zdHJ1Y3Rpb24udHNcbnZhciBERUZBVUxUX1NDSEVNQV9QUkVGSVggPSBcIkpTT04gc2NoZW1hOlwiO1xudmFyIERFRkFVTFRfU0NIRU1BX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIEpTT04gc2NoZW1hIGFib3ZlLlwiO1xudmFyIERFRkFVTFRfR0VORVJJQ19TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIEpTT04uXCI7XG5mdW5jdGlvbiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICBwcm9tcHQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4ID0gc2NoZW1hICE9IG51bGwgPyBERUZBVUxUX1NDSEVNQV9QUkVGSVggOiB2b2lkIDAsXG4gIHNjaGVtYVN1ZmZpeCA9IHNjaGVtYSAhPSBudWxsID8gREVGQVVMVF9TQ0hFTUFfU1VGRklYIDogREVGQVVMVF9HRU5FUklDX1NVRkZJWFxufSkge1xuICByZXR1cm4gW1xuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gcHJvbXB0IDogdm9pZCAwLFxuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gXCJcIiA6IHZvaWQgMCxcbiAgICAvLyBhZGQgYSBuZXdsaW5lIGlmIHByb21wdCBpcyBub3QgbnVsbFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBzY2hlbWEgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHNjaGVtYSkgOiB2b2lkIDAsXG4gICAgc2NoZW1hU3VmZml4XG4gIF0uZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9IG51bGwpLmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBhc1NjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKCkpO1xuICBzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gKCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfSA6IHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvb3V0cHV0LXN0cmF0ZWd5LnRzXG52YXIgbm9TY2hlbWFPdXRwdXRTdHJhdGVneSA9IHtcbiAgdHlwZTogXCJuby1zY2hlbWFcIixcbiAganNvblNjaGVtYTogdm9pZCAwLFxuICB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogeyBwYXJ0aWFsOiB2YWx1ZSwgdGV4dERlbHRhIH0gfTtcbiAgfSxcbiAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICB0ZXh0OiBjb250ZXh0LnRleHQsXG4gICAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgICB1c2FnZTogY29udGV4dC51c2FnZVxuICAgICAgfSlcbiAgICB9IDogeyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBuby1zY2hlbWEgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn07XG52YXIgb2JqZWN0T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiAoe1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBqc29uU2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYSxcbiAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgbm8gdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHJlc3VsdHM6XG4gICAgICAgIHBhcnRpYWw6IHZhbHVlLFxuICAgICAgICB0ZXh0RGVsdGFcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIG9iamVjdCBtb2RlXCJcbiAgICB9KTtcbiAgfVxufSk7XG52YXIgYXJyYXlPdXRwdXRTdHJhdGVneSA9IChzY2hlbWEpID0+IHtcbiAgY29uc3QgeyAkc2NoZW1hLCAuLi5pdGVtU2NoZW1hIH0gPSBzY2hlbWEuanNvblNjaGVtYTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFycmF5IG9mIGVsZW1lbnRzLCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGFycmF5IGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBhcnJheXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyBncmFtbWFyLWd1aWRlZCBnZW5lcmF0aW9uXG4gICAganNvblNjaGVtYToge1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVsZW1lbnRzOiB7IHR5cGU6IFwiYXJyYXlcIiwgaXRlbXM6IGl0ZW1TY2hlbWEgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIGxhdGVzdE9iamVjdCwgaXNGaXJzdERlbHRhLCBpc0ZpbmFsRGVsdGEgfSkge1xuICAgICAgdmFyIF9hMTM7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBjb25zdCByZXN1bHRBcnJheSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoaSA9PT0gaW5wdXRBcnJheS5sZW5ndGggLSAxICYmICFpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRBcnJheS5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaXNoZWRFbGVtZW50Q291bnQgPSAoX2ExMyA9IGxhdGVzdE9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0T2JqZWN0Lmxlbmd0aCkgIT0gbnVsbCA/IF9hMTMgOiAwO1xuICAgICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgICBpZiAoaXNGaXJzdERlbHRhKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIltcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaXNoZWRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIixcIjtcbiAgICAgIH1cbiAgICAgIHRleHREZWx0YSArPSByZXN1bHRBcnJheS5zbGljZShwdWJsaXNoZWRFbGVtZW50Q291bnQpLm1hcCgoZWxlbWVudCkgPT4gSlNPTi5zdHJpbmdpZnkoZWxlbWVudCkpLmpvaW4oXCIsXCIpO1xuICAgICAgaWYgKGlzRmluYWxEZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJdXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHBhcnRpYWw6IHJlc3VsdEFycmF5LFxuICAgICAgICAgIHRleHREZWx0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGlucHV0QXJyYXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMyKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiBpbnB1dEFycmF5IH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKG9yaWdpbmFsU3RyZWFtKSB7XG4gICAgICBsZXQgcHVibGlzaGVkRWxlbWVudHMgPSAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICAgIG9yaWdpbmFsU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBjaHVuay5vYmplY3Q7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBhcnJheS5sZW5ndGg7IHB1Ymxpc2hlZEVsZW1lbnRzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGFycmF5W3B1Ymxpc2hlZEVsZW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59O1xudmFyIGVudW1PdXRwdXRTdHJhdGVneSA9IChlbnVtVmFsdWVzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgLy8gd3JhcCBpbiBvYmplY3QgdGhhdCBjb250YWlucyByZXN1bHQsIHNpbmNlIG1vc3QgTExNcyB3aWxsIG5vdFxuICAgIC8vIGJlIGFibGUgdG8gZ2VuZXJhdGUgYW4gZW51bSB2YWx1ZSBkaXJlY3RseTpcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiB1c2UgZW51bXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyB0b3AtbGV2ZWwgZW51bXNcbiAgICBqc29uU2NoZW1hOiB7XG4gICAgICAkc2NoZW1hOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcmVzdWx0OiB7IHR5cGU6IFwic3RyaW5nXCIsIGVudW06IGVudW1WYWx1ZXMgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbXCJyZXN1bHRcIl0sXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICB9LFxuICAgIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucmVzdWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6ICd2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgc3RyaW5nIGluIHRoZSBcInJlc3VsdFwiIHByb3BlcnR5LidcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUucmVzdWx0O1xuICAgICAgcmV0dXJuIGVudW1WYWx1ZXMuaW5jbHVkZXMocmVzdWx0KSA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdCB9IDoge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIGluIHRoZSBlbnVtXCJcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSxcbiAgICB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInBhcnRpYWwgcmVzdWx0cyBpbiBlbnVtIG1vZGVcIlxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJlbGVtZW50IHN0cmVhbXMgaW4gZW51bSBtb2RlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRPdXRwdXRTdHJhdGVneSh7XG4gIG91dHB1dCxcbiAgc2NoZW1hLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIHN3aXRjaCAob3V0cHV0KSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIG9iamVjdE91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hKHNjaGVtYSkpO1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIGFycmF5T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWEoc2NoZW1hKSk7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICAgIHJldHVybiBlbnVtT3V0cHV0U3RyYXRlZ3koZW51bVZhbHVlcyk7XG4gICAgY2FzZSBcIm5vLXNjaGVtYVwiOlxuICAgICAgcmV0dXJuIG5vU2NoZW1hT3V0cHV0U3RyYXRlZ3k7XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG91dHB1dDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3V0cHV0OiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L3ZhbGlkYXRlLW9iamVjdC1nZW5lcmF0aW9uLWlucHV0LnRzXG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gIG91dHB1dCxcbiAgbW9kZSxcbiAgc2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgZW51bVZhbHVlc1xufSkge1xuICBpZiAob3V0cHV0ICE9IG51bGwgJiYgb3V0cHV0ICE9PSBcIm9iamVjdFwiICYmIG91dHB1dCAhPT0gXCJhcnJheVwiICYmIG91dHB1dCAhPT0gXCJlbnVtXCIgJiYgb3V0cHV0ICE9PSBcIm5vLXNjaGVtYVwiKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIHBhcmFtZXRlcjogXCJvdXRwdXRcIixcbiAgICAgIHZhbHVlOiBvdXRwdXQsXG4gICAgICBtZXNzYWdlOiBcIkludmFsaWQgb3V0cHV0IHR5cGUuXCJcbiAgICB9KTtcbiAgfVxuICBpZiAob3V0cHV0ID09PSBcIm5vLXNjaGVtYVwiKSB7XG4gICAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT09IFwidG9vbFwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibW9kZVwiLFxuICAgICAgICB2YWx1ZTogbW9kZSxcbiAgICAgICAgbWVzc2FnZTogJ01vZGUgbXVzdCBiZSBcImpzb25cIiBmb3Igbm8tc2NoZW1hIG91dHB1dC4nXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYURlc2NyaXB0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgZGVzY3JpcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFOYW1lXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFOYW1lLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBuYW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgcmVxdWlyZWQgZm9yIG9iamVjdCBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igb2JqZWN0IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwiYXJyYXlcIikge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIkVsZW1lbnQgc2NoZW1hIGlzIHJlcXVpcmVkIGZvciBhcnJheSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgYXJyYXkgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJlbnVtXCIpIHtcbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYURlc2NyaXB0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgZGVzY3JpcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hTmFtZVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hTmFtZSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgbmFtZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSByZXF1aXJlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGVudW1WYWx1ZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgbXVzdCBiZSBzdHJpbmdzLlwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQgPSBjcmVhdGVJZEdlbmVyYXRvcih7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlT2JqZWN0KHtcbiAgbW9kZWwsXG4gIGVudW06IGVudW1WYWx1ZXMsXG4gIC8vIHJlbmFtZSBiYyBlbnVtIGlzIHJlc2VydmVkIGJ5IHR5cGVzY3JpcHRcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIG1vZGUsXG4gIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkLFxuICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIG1vZGUsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIGVudW1WYWx1ZXNcbiAgfSk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHsgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgaWYgKG91dHB1dFN0cmF0ZWd5LnR5cGUgPT09IFwibm8tc2NoZW1hXCIgJiYgbW9kZSA9PT0gdm9pZCAwKSB7XG4gICAgbW9kZSA9IFwianNvblwiO1xuICB9XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2NoZW1hXCI6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgIT0gbnVsbCA/IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEpIH0gOiB2b2lkIDAsXG4gICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIFwiYWkuc2V0dGluZ3Mub3V0cHV0XCI6IG91dHB1dFN0cmF0ZWd5LnR5cGUsXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMTMsIF9iO1xuICAgICAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT0gbnVsbCkge1xuICAgICAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgICBsZXQgdXNhZ2U7XG4gICAgICBsZXQgd2FybmluZ3M7XG4gICAgICBsZXQgcmF3UmVzcG9uc2U7XG4gICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICBsZXQgcmVxdWVzdDtcbiAgICAgIGxldCBsb2dwcm9icztcbiAgICAgIGxldCByZXN1bHRQcm92aWRlck1ldGFkYXRhO1xuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgc3lzdGVtOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hID09IG51bGwgPyBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oeyBwcm9tcHQ6IHN5c3RlbSB9KSA6IG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgIHByb21wdDogc3lzdGVtLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvb2xzOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0YW5kYXJkaXplZFByb21wdC50eXBlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExNCwgX2IyLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LWpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBzdGFuZGFyZGl6ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgaWQ6IChfYjIgPSAoX2ExNCA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE0LmlkKSAhPSBudWxsID8gX2IyIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9kID0gKF9jID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9kIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfZiA9IChfZSA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS5tb2RlbElkKSAhPSBudWxsID8gX2YgOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Mi50ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiB0aGUgbW9kZWwgZGlkIG5vdCByZXR1cm4gYSByZXNwb25zZS5cIixcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShyZXN1bHQyLnVzYWdlKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHJlc3VsdDIudGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtyZXN1bHQyLmZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLnByb21wdF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuY29tcGxldGlvbl90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQyLCBvYmplY3RUZXh0OiByZXN1bHQyLnRleHQsIHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQub2JqZWN0VGV4dDtcbiAgICAgICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgICAgICByZXN1bHRQcm92aWRlck1ldGFkYXRhID0gZ2VuZXJhdGVSZXN1bHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICByZXF1ZXN0ID0gKF9hMTMgPSBnZW5lcmF0ZVJlc3VsdC5yZXF1ZXN0KSAhPSBudWxsID8gX2ExMyA6IHt9O1xuICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0sXG4gICAgICAgICAgICB0b29sczogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGlucHV0Rm9ybWF0ID0gc3RhbmRhcmRpemVkUHJvbXB0LnR5cGU7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGlucHV0Rm9ybWF0XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExNCwgX2IyLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUgIT0gbnVsbCA/IHNjaGVtYU5hbWUgOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb24gIT0gbnVsbCA/IHNjaGVtYURlc2NyaXB0aW9uIDogXCJSZXNwb25kIHdpdGggYSBKU09OIG9iamVjdC5cIixcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0LFxuICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3RUZXh0ID0gKF9iMiA9IChfYTE0ID0gcmVzdWx0Mi50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTE0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmFyZ3M7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgaWQ6IChfZCA9IChfYyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYy5pZCkgIT0gbnVsbCA/IF9kIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9mIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfaCA9IChfZyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZy5tb2RlbElkKSAhPSBudWxsID8gX2ggOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0VGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogdGhlIHRvb2wgd2FzIG5vdCBjYWxsZWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UocmVzdWx0Mi51c2FnZSlcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHJlc3VsdDIuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiBvYmplY3RUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0Mi51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQyLCBvYmplY3RUZXh0LCByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgcmVxdWVzdCA9IChfYiA9IGdlbmVyYXRlUmVzdWx0LnJlcXVlc3QpICE9IG51bGwgPyBfYiA6IHt9O1xuICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IHJlc3VsdCB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gb3V0cHV0U3RyYXRlZ3kudmFsaWRhdGVGaW5hbFJlc3VsdChcbiAgICAgICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgICAgIHtcbiAgICAgICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSlcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uUmVzdWx0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0KHtcbiAgICAgICAgb2JqZWN0OiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLFxuICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9wdGlvbnMub2JqZWN0O1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gICAgdGhpcy5sb2dwcm9icyA9IG9wdGlvbnMubG9ncHJvYnM7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTEzO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTEzID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTEzIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBwYXJzZVBhcnRpYWxKc29uXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIHV0aWwvZGVsYXllZC1wcm9taXNlLnRzXG52YXIgRGVsYXllZFByb21pc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInBlbmRpbmdcIiB9O1xuICAgIHRoaXMuX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVqZWN0ID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJlc29sdmUodGhpcy5zdGF0dXMudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cy50eXBlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgcmVqZWN0KHRoaXMuc3RhdHVzLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gIH1cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIHZhciBfYTEzO1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlc29sdmVkXCIsIHZhbHVlIH07XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgKF9hMTMgPSB0aGlzLl9yZXNvbHZlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMy5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVqZWN0KGVycm9yKSB7XG4gICAgdmFyIF9hMTM7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicmVqZWN0ZWRcIiwgZXJyb3IgfTtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICAoX2ExMyA9IHRoaXMuX3JlamVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTMuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICB9XG59O1xuXG4vLyB1dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9jcmVhdGUtc3RpdGNoYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKSB7XG4gIGxldCBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsO1xuICBsZXQgaXNDbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHdhaXRGb3JOZXdTdHJlYW0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICBjb25zdCBwcm9jZXNzUHVsbCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDbG9zZWQgJiYgaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgd2FpdEZvck5ld1N0cmVhbSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBhd2FpdCB3YWl0Rm9yTmV3U3RyZWFtLnByb21pc2U7XG4gICAgICByZXR1cm4gcHJvY2Vzc1B1bGwoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGlubmVyU3RyZWFtUmVhZGVyc1swXS5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXdhaXQgcHJvY2Vzc1B1bGwoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlclBhcmFtKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyUGFyYW07XG4gICAgICB9LFxuICAgICAgcHVsbDogcHJvY2Vzc1B1bGwsXG4gICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIGlubmVyU3RyZWFtUmVhZGVycykge1xuICAgICAgICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGFkZFN0cmVhbTogKGlubmVyU3RyZWFtKSA9PiB7XG4gICAgICBpZiAoaXNDbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBpbm5lciBzdHJlYW06IG91dGVyIHN0cmVhbSBpcyBjbG9zZWRcIik7XG4gICAgICB9XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMucHVzaChpbm5lclN0cmVhbS5nZXRSZWFkZXIoKSk7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtLnJlc29sdmUoKTtcbiAgICB9LFxuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtLnJlc29sdmUoKTtcbiAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9ub3cudHNcbmZ1bmN0aW9uIG5vdygpIHtcbiAgdmFyIF9hMTMsIF9iO1xuICByZXR1cm4gKF9iID0gKF9hMTMgPSBnbG9iYWxUaGlzID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMy5ub3coKSkgIT0gbnVsbCA/IF9iIDogRGF0ZS5ub3coKTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDIgPSBjcmVhdGVJZEdlbmVyYXRvcjIoeyBwcmVmaXg6IFwiYWlvYmpcIiwgc2l6ZTogMjQgfSk7XG5mdW5jdGlvbiBzdHJlYW1PYmplY3Qoe1xuICBtb2RlbCxcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIG1vZGUsXG4gIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIG9uRmluaXNoLFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDIsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICBub3c6IG5vdzIgPSBub3dcbiAgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIG1vZGUsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHsgb3V0cHV0LCBzY2hlbWE6IGlucHV0U2NoZW1hIH0pO1xuICBpZiAob3V0cHV0U3RyYXRlZ3kudHlwZSA9PT0gXCJuby1zY2hlbWFcIiAmJiBtb2RlID09PSB2b2lkIDApIHtcbiAgICBtb2RlID0gXCJqc29uXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0KHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5ncyxcbiAgICBtYXhSZXRyaWVzLFxuICAgIGFib3J0U2lnbmFsLFxuICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBpbnB1dFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgbW9kZSxcbiAgICBvbkZpbmlzaCxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBub3c6IG5vdzJcbiAgfSk7XG59XG52YXIgRGVmYXVsdFN0cmVhbU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsLFxuICAgIGhlYWRlcnMsXG4gICAgdGVsZW1ldHJ5LFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIGlucHV0UHJvdmlkZXJNZXRhZGF0YSxcbiAgICBtb2RlLFxuICAgIG9uRmluaXNoLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIG5vdzogbm93MlxuICB9KSB7XG4gICAgdGhpcy5vYmplY3RQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy51c2FnZVByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy53YXJuaW5nc1Byb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnJlcXVlc3RQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5yZXNwb25zZVByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnN0aXRjaGFibGVTdHJlYW0gPSBjcmVhdGVTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZ1xuICAgIH0pO1xuICAgIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgbW9kZWwsXG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlLFxuICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbikgPT4ge1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FsbE9wdGlvbnM7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lcjtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgICBzeXN0ZW06IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgPT0gbnVsbCA/IGluamVjdEpzb25JbnN0cnVjdGlvbih7IHByb21wdDogc3lzdGVtIH0pIDogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHN5c3RlbSA6IGluamVjdEpzb25JbnN0cnVjdGlvbih7XG4gICAgICAgICAgICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0b29sczogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtanNvblwiLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSxcbiAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHN0YW5kYXJkaXplZFByb21wdC50eXBlLFxuICAgICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBpbnB1dFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0sXG4gICAgICAgICAgICAgIHRvb2xzOiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC10b29sXCIsXG4gICAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSAhPSBudWxsID8gc2NoZW1hTmFtZSA6IFwianNvblwiLFxuICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwgPyBzY2hlbWFEZXNjcmlwdGlvbiA6IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHN0YW5kYXJkaXplZFByb21wdC50eXBlLFxuICAgICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBpbnB1dFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsuYXJnc1RleHREZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiTW9kZWwgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgb2JqZWN0IGdlbmVyYXRpb24gbW9kZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSwgcmVxdWVzdCB9LFxuICAgICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zXG4gICAgICAgIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjYWxsT3B0aW9ucy5pbnB1dEZvcm1hdFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGNhbGxPcHRpb25zLnByb21wdClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlLFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogc2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBzZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBub3cyKCksXG4gICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbShjYWxsT3B0aW9ucylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc2VsZi5yZXF1ZXN0UHJvbWlzZS5yZXNvbHZlKHJlcXVlc3QgIT0gbnVsbCA/IHJlcXVlc3QgOiB7fSk7XG4gICAgICAgIGxldCB1c2FnZTtcbiAgICAgICAgbGV0IGZpbmlzaFJlYXNvbjtcbiAgICAgICAgbGV0IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIGxldCBvYmplY3QyO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgICAgICBsZXQgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgIHRpbWVzdGFtcDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICAgIH07XG4gICAgICAgIGxldCBsYXRlc3RPYmplY3RKc29uID0gdm9pZCAwO1xuICAgICAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgICAgICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzRmlyc3REZWx0YSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpKS5waXBlVGhyb3VnaChcbiAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB2YXIgX2ExMywgX2IsIF9jO1xuICAgICAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRleHREZWx0YSArPSBjaHVuaztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbiwgc3RhdGU6IHBhcnNlU3RhdGUgfSA9IHBhcnNlUGFydGlhbEpzb24oYWNjdW11bGF0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE9iamVjdEpzb24gIT09IHZvaWQgMCAmJiAhaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdEpzb24sIGN1cnJlbnRPYmplY3RKc29uKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhLFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5hbERlbHRhOiBwYXJzZVN0YXRlID09PSBcInN1Y2Nlc3NmdWwtcGFyc2VcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzICYmICFpc0RlZXBFcXVhbERhdGEoXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsXG4gICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdEpzb24gPSBjdXJyZW50T2JqZWN0SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXRlc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnRleHREZWx0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2ExMyA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExMyA6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYiA9IGNodW5rLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9iIDogcmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2MgPSBjaHVuay5tb2RlbElkKSAhPSBudWxsID8gX2MgOiByZXNwb25zZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICAgICAgaWYgKHRleHREZWx0YSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgdGV4dERlbHRhIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICAgICAgdXNhZ2UgPSBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UoY2h1bmsudXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyAuLi5jaHVuaywgdXNhZ2UsIHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgICAgc2VsZi51c2FnZVByb21pc2UucmVzb2x2ZSh1c2FnZSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlLnJlc29sdmUocHJvdmlkZXJNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLnJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZUZpbmFsUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3RKc29uLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogYWNjdW11bGF0ZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgIHVzYWdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDIgPSB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdFByb21pc2UucmVzb2x2ZShvYmplY3QyKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogYWNjdW11bGF0ZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgIHVzYWdlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICAgICAgICB1c2FnZTogZmluYWxVc2FnZSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogb2JqZWN0MixcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcjIpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc2VsZi5zdGl0Y2hhYmxlU3RyZWFtLmFkZFN0cmVhbSh0cmFuc2Zvcm1lZFN0cmVhbSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBzZWxmLnN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtKFxuICAgICAgICBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBzZWxmLnN0aXRjaGFibGVTdHJlYW0uY2xvc2UoKTtcbiAgICB9KTtcbiAgICB0aGlzLm91dHB1dFN0cmF0ZWd5ID0gb3V0cHV0U3RyYXRlZ3k7XG4gIH1cbiAgZ2V0IG9iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3RQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy51c2FnZVByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy53YXJuaW5nc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlc3BvbnNlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsub2JqZWN0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGNodW5rLmVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBlbGVtZW50U3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFN0cmF0ZWd5LmNyZWF0ZUVsZW1lbnRTdHJlYW0oXG4gICAgICB0aGlzLnN0aXRjaGFibGVTdHJlYW0uc3RyZWFtXG4gICAgKTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGNodW5rLmVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMuc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXR1czogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExMztcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hMTMgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTMgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycywge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBlcnJvcnMvaW5kZXgudHNcbmltcG9ydCB7XG4gIEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjEyLFxuICBBUElDYWxsRXJyb3IgYXMgQVBJQ2FsbEVycm9yMixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yIGFzIEludmFsaWRQcm9tcHRFcnJvcjIsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjIsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBlcnJvcnMvaW52YWxpZC10b29sLWFyZ3VtZW50cy1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOCwgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU4ID0gXCJBSV9JbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yXCI7XG52YXIgbWFya2VyOCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDggPSBTeW1ib2wuZm9yKG1hcmtlcjgpO1xudmFyIF9hODtcbnZhciBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sQXJncyxcbiAgICB0b29sTmFtZSxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgYXJndW1lbnRzIGZvciB0b29sICR7dG9vbE5hbWV9OiAke2dldEVycm9yTWVzc2FnZTIoXG4gICAgICBjYXVzZVxuICAgICl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xBcmdzID0gdG9vbEFyZ3M7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I4Lmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBlcnJvcnMvbm8tc3VjaC10b29sLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOSA9IFwiQUlfTm9TdWNoVG9vbEVycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBOb1N1Y2hUb29sRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xOYW1lLFxuICAgIGF2YWlsYWJsZVRvb2xzID0gdm9pZCAwLFxuICAgIG1lc3NhZ2UgPSBgTW9kZWwgdHJpZWQgdG8gY2FsbCB1bmF2YWlsYWJsZSB0b29sICcke3Rvb2xOYW1lfScuICR7YXZhaWxhYmxlVG9vbHMgPT09IHZvaWQgMCA/IFwiTm8gdG9vbHMgYXJlIGF2YWlsYWJsZS5cIiA6IGBBdmFpbGFibGUgdG9vbHM6ICR7YXZhaWxhYmxlVG9vbHMuam9pbihcIiwgXCIpfS5gfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTldID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGVUb29scyA9IGF2YWlsYWJsZVRvb2xzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I5Lmhhc01hcmtlcihlcnJvciwgbWFya2VyOSk7XG4gIH1cbn07XG5fYTkgPSBzeW1ib2w5O1xuXG4vLyBlcnJvcnMvdG9vbC1jYWxsLXJlcGFpci1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAsIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTAgPSBcIkFJX1Rvb2xDYWxsUmVwYWlyRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMCA9IFN5bWJvbC5mb3IobWFya2VyMTApO1xudmFyIF9hMTA7XG52YXIgVG9vbENhbGxSZXBhaXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEwIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNhdXNlLFxuICAgIG9yaWdpbmFsRXJyb3IsXG4gICAgbWVzc2FnZSA9IGBFcnJvciByZXBhaXJpbmcgdG9vbCBjYWxsOiAke2dldEVycm9yTWVzc2FnZTMoY2F1c2UpfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTEwLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxufTtcbl9hMTAgPSBzeW1ib2wxMDtcblxuLy8gZXJyb3JzL3Rvb2wtZXhlY3V0aW9uLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMSwgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMSA9IFwiQUlfVG9vbEV4ZWN1dGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTEgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTEgPSBTeW1ib2wuZm9yKG1hcmtlcjExKTtcbnZhciBfYTExO1xudmFyIFRvb2xFeGVjdXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjExIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xBcmdzLFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlNChjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTEsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjExLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTEpO1xuICB9XG59O1xuX2ExMSA9IHN5bWJvbDExO1xuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuaW1wb3J0IHsgYXNTY2hlbWEgYXMgYXNTY2hlbWEyIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gY29yZS91dGlsL2lzLW5vbi1lbXB0eS1vYmplY3QudHNcbmZ1bmN0aW9uIGlzTm9uRW1wdHlPYmplY3Qob2JqZWN0Mikge1xuICByZXR1cm4gb2JqZWN0MiAhPSBudWxsICYmIE9iamVjdC5rZXlzKG9iamVjdDIpLmxlbmd0aCA+IDA7XG59XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5mdW5jdGlvbiBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIGFjdGl2ZVRvb2xzXG59KSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHZvaWQgMCxcbiAgICAgIHRvb2xDaG9pY2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgY29uc3QgZmlsdGVyZWRUb29scyA9IGFjdGl2ZVRvb2xzICE9IG51bGwgPyBPYmplY3QuZW50cmllcyh0b29scykuZmlsdGVyKFxuICAgIChbbmFtZTEzXSkgPT4gYWN0aXZlVG9vbHMuaW5jbHVkZXMobmFtZTEzKVxuICApIDogT2JqZWN0LmVudHJpZXModG9vbHMpO1xuICByZXR1cm4ge1xuICAgIHRvb2xzOiBmaWx0ZXJlZFRvb2xzLm1hcCgoW25hbWUxMywgdG9vbDJdKSA9PiB7XG4gICAgICBjb25zdCB0b29sVHlwZSA9IHRvb2wyLnR5cGU7XG4gICAgICBzd2l0Y2ggKHRvb2xUeXBlKSB7XG4gICAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgbmFtZTogbmFtZTEzLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wyLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogYXNTY2hlbWEyKHRvb2wyLnBhcmFtZXRlcnMpLmpzb25TY2hlbWFcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicHJvdmlkZXItZGVmaW5lZFwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInByb3ZpZGVyLWRlZmluZWRcIixcbiAgICAgICAgICAgIG5hbWU6IG5hbWUxMyxcbiAgICAgICAgICAgIGlkOiB0b29sMi5pZCxcbiAgICAgICAgICAgIGFyZ3M6IHRvb2wyLmFyZ3NcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gdG9vbFR5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0b29sIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdG9vbENob2ljZTogdG9vbENob2ljZSA9PSBudWxsID8geyB0eXBlOiBcImF1dG9cIiB9IDogdHlwZW9mIHRvb2xDaG9pY2UgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IHRvb2xDaG9pY2UgfSA6IHsgdHlwZTogXCJ0b29sXCIsIHRvb2xOYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL3NwbGl0LW9uLWxhc3Qtd2hpdGVzcGFjZS50c1xudmFyIGxhc3RXaGl0ZXNwYWNlUmVnZXhwID0gL14oW1xcc1xcU10qPykoXFxzKykoXFxTKikkLztcbmZ1bmN0aW9uIHNwbGl0T25MYXN0V2hpdGVzcGFjZSh0ZXh0Mikge1xuICBjb25zdCBtYXRjaCA9IHRleHQyLm1hdGNoKGxhc3RXaGl0ZXNwYWNlUmVnZXhwKTtcbiAgcmV0dXJuIG1hdGNoID8geyBwcmVmaXg6IG1hdGNoWzFdLCB3aGl0ZXNwYWNlOiBtYXRjaFsyXSwgc3VmZml4OiBtYXRjaFszXSB9IDogdm9pZCAwO1xufVxuXG4vLyBjb3JlL3V0aWwvcmVtb3ZlLXRleHQtYWZ0ZXItbGFzdC13aGl0ZXNwYWNlLnRzXG5mdW5jdGlvbiByZW1vdmVUZXh0QWZ0ZXJMYXN0V2hpdGVzcGFjZSh0ZXh0Mikge1xuICBjb25zdCBtYXRjaCA9IHNwbGl0T25MYXN0V2hpdGVzcGFjZSh0ZXh0Mik7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoLnByZWZpeCArIG1hdGNoLndoaXRlc3BhY2UgOiB0ZXh0Mjtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3BhcnNlLXRvb2wtY2FsbC50c1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMiwgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXMzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGFzU2NoZW1hIGFzIGFzU2NoZW1hMyB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiBwYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzLFxuICByZXBhaXJUb29sQ2FsbCxcbiAgc3lzdGVtLFxuICBtZXNzYWdlc1xufSkge1xuICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGwsIHRvb2xzIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChyZXBhaXJUb29sQ2FsbCA9PSBudWxsIHx8ICEoTm9TdWNoVG9vbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpIHx8IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgbGV0IHJlcGFpcmVkVG9vbENhbGwgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICByZXBhaXJlZFRvb2xDYWxsID0gYXdhaXQgcmVwYWlyVG9vbENhbGwoe1xuICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgdG9vbHMsXG4gICAgICAgIHBhcmFtZXRlclNjaGVtYTogKHsgdG9vbE5hbWUgfSkgPT4gYXNTY2hlbWEzKHRvb2xzW3Rvb2xOYW1lXS5wYXJhbWV0ZXJzKS5qc29uU2NoZW1hLFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAocmVwYWlyRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBUb29sQ2FsbFJlcGFpckVycm9yKHtcbiAgICAgICAgY2F1c2U6IHJlcGFpckVycm9yLFxuICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyZXBhaXJlZFRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IHJlcGFpcmVkVG9vbENhbGwsIHRvb2xzIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb1BhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEzKHRvb2wyLnBhcmFtZXRlcnMpO1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IHRvb2xDYWxsLmFyZ3MudHJpbSgpID09PSBcIlwiID8gc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWU6IHt9LCBzY2hlbWEgfSkgOiBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRvb2xDYWxsLmFyZ3MsIHNjaGVtYSB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgdG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lLFxuICAgIGFyZ3M6IHBhcnNlUmVzdWx0LnZhbHVlXG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC90by1yZXNwb25zZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgdGV4dDogdGV4dDIgPSBcIlwiLFxuICB0b29scyxcbiAgdG9vbENhbGxzLFxuICB0b29sUmVzdWx0c1xufSkge1xuICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogdGV4dDIgfSwgLi4udG9vbENhbGxzXVxuICB9KTtcbiAgaWYgKHRvb2xSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0cy5tYXAoKHRvb2xSZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sUmVzdWx0LnRvb2xOYW1lXTtcbiAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xSZXN1bHQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogdG9vbFJlc3VsdC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHRvb2xSZXN1bHQucmVzdWx0KSxcbiAgICAgICAgICBleHBlcmltZW50YWxfY29udGVudDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQoXG4gICAgICAgICAgICB0b29sUmVzdWx0LnJlc3VsdFxuICAgICAgICAgIClcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogdG9vbFJlc3VsdC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiB0b29sUmVzdWx0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogdG9vbFJlc3VsdC5yZXN1bHRcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMyA9IGNyZWF0ZUlkR2VuZXJhdG9yMyh7IHByZWZpeDogXCJhaXR4dFwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgbWF4U3RlcHMgPSAxLFxuICBleHBlcmltZW50YWxfb3V0cHV0OiBvdXRwdXQsXG4gIGV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzOiBjb250aW51ZVN0ZXBzID0gZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29sczogYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMyxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgb25TdGVwRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YXIgX2ExMztcbiAgaWYgKG1heFN0ZXBzIDwgMSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwibWF4U3RlcHNcIixcbiAgICAgIHZhbHVlOiBtYXhTdGVwcyxcbiAgICAgIG1lc3NhZ2U6IFwibWF4U3RlcHMgbXVzdCBiZSBhdCBsZWFzdCAxXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgcHJvbXB0OiB7XG4gICAgICBzeXN0ZW06IChfYTEzID0gb3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQuaW5qZWN0SW50b1N5c3RlbVByb21wdCh7IHN5c3RlbSwgbW9kZWwgfSkpICE9IG51bGwgPyBfYTEzIDogc3lzdGVtLFxuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZXNcbiAgICB9LFxuICAgIHRvb2xzXG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubWF4U3RlcHNcIjogbWF4U3RlcHNcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICB2YXIgX2ExNCwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgY29uc3QgbW9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UoeyB0b29scywgdG9vbENob2ljZSwgYWN0aXZlVG9vbHMgfSlcbiAgICAgIH07XG4gICAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgIGxldCBjdXJyZW50VG9vbENhbGxzID0gW107XG4gICAgICBsZXQgY3VycmVudFRvb2xSZXN1bHRzID0gW107XG4gICAgICBsZXQgc3RlcENvdW50ID0gMDtcbiAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICAgIGxldCB0ZXh0MiA9IFwiXCI7XG4gICAgICBjb25zdCBzdGVwcyA9IFtdO1xuICAgICAgbGV0IHVzYWdlID0ge1xuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgIHRvdGFsVG9rZW5zOiAwXG4gICAgICB9O1xuICAgICAgbGV0IHN0ZXBUeXBlID0gXCJpbml0aWFsXCI7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IHByb21wdEZvcm1hdCA9IHN0ZXBDb3VudCA9PT0gMCA/IGluaXRpYWxQcm9tcHQudHlwZSA6IFwibWVzc2FnZXNcIjtcbiAgICAgICAgY29uc3Qgc3RlcElucHV0TWVzc2FnZXMgPSBbXG4gICAgICAgICAgLi4uaW5pdGlhbFByb21wdC5tZXNzYWdlcyxcbiAgICAgICAgICAuLi5yZXNwb25zZU1lc3NhZ2VzXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICB0eXBlOiBwcm9tcHRGb3JtYXQsXG4gICAgICAgICAgICBzeXN0ZW06IGluaXRpYWxQcm9tcHQuc3lzdGVtLFxuICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybFxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7IGlucHV0OiAoKSA9PiBwcm9tcHRGb3JtYXQgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTE1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hMTUgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNS5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gbW9kZS50b29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShtb2RlLnRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3Quc3RvcF9zZXF1ZW5jZXNcIjogc2V0dGluZ3Muc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTE1LCBfYjIsIF9jMiwgX2QyLCBfZTIsIF9mMjtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogb3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQoeyBtb2RlbCB9KSxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoX2IyID0gKF9hMTUgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE1LmlkKSAhPSBudWxsID8gX2IyIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZDIgPSAoX2MyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9kMiA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mMiA9IChfZTIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZTIubW9kZWxJZCkgIT0gbnVsbCA/IF9mMiA6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHJlc3VsdC50ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdC50b29sQ2FsbHMpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdC51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0LmZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0LCByZXNwb25zZTogcmVzcG9uc2VEYXRhIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRvb2xDYWxscyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICgoX2ExNCA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRvb2xDYWxscykgIT0gbnVsbCA/IF9hMTQgOiBbXSkubWFwKFxuICAgICAgICAgICAgKHRvb2xDYWxsKSA9PiBwYXJzZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICByZXBhaXJUb29sQ2FsbCxcbiAgICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50VG9vbFJlc3VsdHMgPSB0b29scyA9PSBudWxsID8gW10gOiBhd2FpdCBleGVjdXRlVG9vbHMoe1xuICAgICAgICAgIHRvb2xDYWxsczogY3VycmVudFRvb2xDYWxscyxcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY3VycmVudFVzYWdlID0gY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKFxuICAgICAgICAgIGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlXG4gICAgICAgICk7XG4gICAgICAgIHVzYWdlID0gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlLCBjdXJyZW50VXNhZ2UpO1xuICAgICAgICBsZXQgbmV4dFN0ZXBUeXBlID0gXCJkb25lXCI7XG4gICAgICAgIGlmICgrK3N0ZXBDb3VudCA8IG1heFN0ZXBzKSB7XG4gICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uID09PSBcImxlbmd0aFwiICYmIC8vIG9ubHkgdXNlIGNvbnRpbnVlIHdoZW4gdGhlcmUgYXJlIG5vIHRvb2wgY2FsbHM6XG4gICAgICAgICAgY3VycmVudFRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwiY29udGludWVcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICBjdXJyZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgICAgICBjdXJyZW50VG9vbFJlc3VsdHMubGVuZ3RoID09PSBjdXJyZW50VG9vbENhbGxzLmxlbmd0aFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJ0b29sLXJlc3VsdFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSAoX2IgPSBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICAgICAgICBjb25zdCBzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZCA9IHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgJiYgLy8gb25seSBmb3IgY29udGludWUgc3RlcHNcbiAgICAgICAgdGV4dDIudHJpbUVuZCgpICE9PSB0ZXh0MiA/IG9yaWdpbmFsVGV4dC50cmltU3RhcnQoKSA6IG9yaWdpbmFsVGV4dDtcbiAgICAgICAgY29uc3Qgc3RlcFRleHQgPSBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIiA/IHJlbW92ZVRleHRBZnRlckxhc3RXaGl0ZXNwYWNlKHN0ZXBUZXh0TGVhZGluZ1doaXRlc3BhY2VUcmltbWVkKSA6IHN0ZXBUZXh0TGVhZGluZ1doaXRlc3BhY2VUcmltbWVkO1xuICAgICAgICB0ZXh0MiA9IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiIHx8IHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyB0ZXh0MiArIHN0ZXBUZXh0IDogc3RlcFRleHQ7XG4gICAgICAgIGlmIChzdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSByZXNwb25zZU1lc3NhZ2VzW3Jlc3BvbnNlTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBsYXN0TWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsYXN0TWVzc2FnZS5jb250ZW50ICs9IHN0ZXBUZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0TWVzc2FnZS5jb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiBzdGVwVGV4dCxcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goXG4gICAgICAgICAgICAuLi50b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICAgICAgdG9vbHM6IHRvb2xzICE9IG51bGwgPyB0b29scyA6IHt9LFxuICAgICAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U3RlcFJlc3VsdCA9IHtcbiAgICAgICAgICBzdGVwVHlwZSxcbiAgICAgICAgICB0ZXh0OiBzdGVwVGV4dCxcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbFJlc3VsdHM6IGN1cnJlbnRUb29sUmVzdWx0cyxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICB1c2FnZTogY3VycmVudFVzYWdlLFxuICAgICAgICAgIHdhcm5pbmdzOiBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnMsXG4gICAgICAgICAgcmVxdWVzdDogKF9jID0gY3VycmVudE1vZGVsUmVzcG9uc2UucmVxdWVzdCkgIT0gbnVsbCA/IF9jIDoge30sXG4gICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgICAgaGVhZGVyczogKF9kID0gY3VycmVudE1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5oZWFkZXJzLFxuICAgICAgICAgICAgLy8gZGVlcCBjbG9uZSBtc2dzIHRvIGF2b2lkIG11dGF0aW5nIHBhc3QgbWVzc2FnZXMgaW4gbXVsdGktc3RlcDpcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlTWVzc2FnZXMpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgaXNDb250aW51ZWQ6IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiXG4gICAgICAgIH07XG4gICAgICAgIHN0ZXBzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goY3VycmVudFN0ZXBSZXN1bHQpKTtcbiAgICAgICAgc3RlcFR5cGUgPSBuZXh0U3RlcFR5cGU7XG4gICAgICB9IHdoaWxlIChzdGVwVHlwZSAhPT0gXCJkb25lXCIpO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRvb2xDYWxscylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQoe1xuICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgb3V0cHV0OiBvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5wYXJzZU91dHB1dChcbiAgICAgICAgICB7IHRleHQ6IHRleHQyIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzcG9uc2U6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgICAgdXNhZ2VcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHRvb2xDYWxsczogY3VycmVudFRvb2xDYWxscyxcbiAgICAgICAgdG9vbFJlc3VsdHM6IGN1cnJlbnRUb29sUmVzdWx0cyxcbiAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlLFxuICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgIHJlcXVlc3Q6IChfZSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlcXVlc3QpICE9IG51bGwgPyBfZSA6IHt9LFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgIGhlYWRlcnM6IChfZiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2YuaGVhZGVycyxcbiAgICAgICAgICBtZXNzYWdlczogcmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9iczogY3VycmVudE1vZGVsUmVzcG9uc2UubG9ncHJvYnMsXG4gICAgICAgIHN0ZXBzLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xzKHtcbiAgdG9vbENhbGxzLFxuICB0b29scyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIG1lc3NhZ2VzLFxuICBhYm9ydFNpZ25hbFxufSkge1xuICBjb25zdCB0b29sUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRvb2xDYWxscy5tYXAoYXN5bmMgKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MgfSkgPT4ge1xuICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5leGVjdXRlKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWNvcmRTcGFuKHtcbiAgICAgICAgbmFtZTogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sTmFtZSxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuaWRcIjogdG9vbENhbGxJZCxcbiAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICB0cmFjZXIsXG4gICAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdG9vbDIuZXhlY3V0ZShhcmdzLCB7XG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwucmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdDIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb29sRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgdG9vbEFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHJlc3VsdFxuICAgICAgfTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gdG9vbFJlc3VsdHMuZmlsdGVyKFxuICAgIChyZXN1bHQpID0+IHJlc3VsdCAhPSBudWxsXG4gICk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcbiAgICB0aGlzLnRvb2xDYWxscyA9IG9wdGlvbnMudG9vbENhbGxzO1xuICAgIHRoaXMudG9vbFJlc3VsdHMgPSBvcHRpb25zLnRvb2xSZXN1bHRzO1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgIHRoaXMuc3RlcHMgPSBvcHRpb25zLnN0ZXBzO1xuICAgIHRoaXMuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5sb2dwcm9icyA9IG9wdGlvbnMubG9ncHJvYnM7XG4gICAgdGhpcy5leHBlcmltZW50YWxfb3V0cHV0ID0gb3B0aW9ucy5vdXRwdXQ7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9vdXRwdXQudHNcbnZhciBvdXRwdXRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQob3V0cHV0X2V4cG9ydHMsIHtcbiAgb2JqZWN0OiAoKSA9PiBvYmplY3QsXG4gIHRleHQ6ICgpID0+IHRleHRcbn0pO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMywgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXM0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGFzU2NoZW1hIGFzIGFzU2NoZW1hNCB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG52YXIgdGV4dCA9ICgpID0+ICh7XG4gIHR5cGU6IFwidGV4dFwiLFxuICByZXNwb25zZUZvcm1hdDogKCkgPT4gKHsgdHlwZTogXCJ0ZXh0XCIgfSksXG4gIGluamVjdEludG9TeXN0ZW1Qcm9tcHQoeyBzeXN0ZW0gfSkge1xuICAgIHJldHVybiBzeXN0ZW07XG4gIH0sXG4gIHBhcnNlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSkge1xuICAgIHJldHVybiB0ZXh0MjtcbiAgfVxufSk7XG52YXIgb2JqZWN0ID0gKHtcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYVxufSkgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTQoaW5wdXRTY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcmVzcG9uc2VGb3JtYXQ6ICh7IG1vZGVsIH0pID0+ICh7XG4gICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgIHNjaGVtYTogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHNjaGVtYS5qc29uU2NoZW1hIDogdm9pZCAwXG4gICAgfSksXG4gICAgaW5qZWN0SW50b1N5c3RlbVByb21wdCh7IHN5c3RlbSwgbW9kZWwgfSkge1xuICAgICAgcmV0dXJuIG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9tcHQ6IHN5c3RlbSxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYXJzZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTjMoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dC51c2FnZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlczQoe1xuICAgICAgICB2YWx1ZTogcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgICAgIHNjaGVtYVxuICAgICAgfSk7XG4gICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dC51c2FnZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGZvcm1hdERhdGFTdHJlYW1QYXJ0IGFzIGZvcm1hdERhdGFTdHJlYW1QYXJ0MiB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9tZXJnZS1zdHJlYW1zLnRzXG5mdW5jdGlvbiBtZXJnZVN0cmVhbXMoc3RyZWFtMSwgc3RyZWFtMikge1xuICBjb25zdCByZWFkZXIxID0gc3RyZWFtMS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgcmVhZGVyMiA9IHN0cmVhbTIuZ2V0UmVhZGVyKCk7XG4gIGxldCBsYXN0UmVhZDEgPSB2b2lkIDA7XG4gIGxldCBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gIGxldCBzdHJlYW0xRG9uZSA9IGZhbHNlO1xuICBsZXQgc3RyZWFtMkRvbmUgPSBmYWxzZTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmVhbTEoY29udHJvbGxlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobGFzdFJlYWQxID09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYXN0UmVhZDE7XG4gICAgICBsYXN0UmVhZDEgPSB2b2lkIDA7XG4gICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmVhbTIoY29udHJvbGxlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobGFzdFJlYWQyID09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYXN0UmVhZDI7XG4gICAgICBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RyZWFtMURvbmUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMihjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbTJEb25lKSB7XG4gICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTEoY29udHJvbGxlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RSZWFkMSA9IHJlYWRlcjEucmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHJlYWRlcjIucmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0LCByZWFkZXIgfSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgbGFzdFJlYWQxLnRoZW4oKHJlc3VsdDIpID0+ICh7IHJlc3VsdDogcmVzdWx0MiwgcmVhZGVyOiByZWFkZXIxIH0pKSxcbiAgICAgICAgICBsYXN0UmVhZDIudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjIgfSkpXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRlciA9PT0gcmVhZGVyMSkge1xuICAgICAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgc3RyZWFtMURvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBzdHJlYW0yRG9uZSA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgICAgcmVhZGVyMS5jYW5jZWwoKTtcbiAgICAgIHJlYWRlcjIuY2FuY2VsKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3J1bi10b29scy10cmFuc2Zvcm1hdGlvbi50c1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgdG9vbHMsXG4gIGdlbmVyYXRvclN0cmVhbSxcbiAgdG9vbENhbGxTdHJlYW1pbmcsXG4gIHRyYWNlcixcbiAgdGVsZW1ldHJ5LFxuICBzeXN0ZW0sXG4gIG1lc3NhZ2VzLFxuICBhYm9ydFNpZ25hbCxcbiAgcmVwYWlyVG9vbENhbGxcbn0pIHtcbiAgbGV0IHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIGNvbnN0IHRvb2xSZXN1bHRzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZVRvb2xDYWxscyA9IHt9O1xuICBjb25zdCBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGNhbkNsb3NlID0gZmFsc2U7XG4gIGxldCBmaW5pc2hDaHVuayA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gYXR0ZW1wdENsb3NlKCkge1xuICAgIGlmIChjYW5DbG9zZSAmJiBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLnNpemUgPT09IDApIHtcbiAgICAgIGlmIChmaW5pc2hDaHVuayAhPSBudWxsKSB7XG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKGZpbmlzaENodW5rKTtcbiAgICAgIH1cbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBmb3J3YXJkU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICBpZiAodG9vbENhbGxTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGlmICghYWN0aXZlVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFjdGl2ZVRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1kZWx0YVwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgIGFyZ3NUZXh0RGVsdGE6IGNodW5rLmFyZ3NUZXh0RGVsdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBhd2FpdCBwYXJzZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rLFxuICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRvb2xDYWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgaWYgKHRvb2wyLmV4ZWN1dGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCB0b29sRXhlY3V0aW9uSWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbC5hcmdzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4gdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzLCB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oXG4gICAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgVG9vbEV4ZWN1dGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xBcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgIGZpbmlzaENodW5rID0ge1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgbG9ncHJvYnM6IGNodW5rLmxvZ3Byb2JzLFxuICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShjaHVuay51c2FnZSksXG4gICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaCgpIHtcbiAgICAgIGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIGF0dGVtcHRDbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGdlbmVyYXRvclN0cmVhbS5waXBlVGhyb3VnaChmb3J3YXJkU3RyZWFtKS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW0ucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkNCA9IGNyZWF0ZUlkR2VuZXJhdG9yNCh7IHByZWZpeDogXCJhaXR4dFwiLCBzaXplOiAyNCB9KTtcbmZ1bmN0aW9uIHN0cmVhbVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIG1heFN0ZXBzID0gMSxcbiAgZXhwZXJpbWVudGFsX2NvbnRpbnVlU3RlcHM6IGNvbnRpbnVlU3RlcHMgPSBmYWxzZSxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgZXhwZXJpbWVudGFsX3Rvb2xDYWxsU3RyZWFtaW5nOiB0b29sQ2FsbFN0cmVhbWluZyA9IGZhbHNlLFxuICBleHBlcmltZW50YWxfYWN0aXZlVG9vbHM6IGFjdGl2ZVRvb2xzLFxuICBleHBlcmltZW50YWxfcmVwYWlyVG9vbENhbGw6IHJlcGFpclRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gIG9uQ2h1bmssXG4gIG9uRmluaXNoLFxuICBvblN0ZXBGaW5pc2gsXG4gIF9pbnRlcm5hbDoge1xuICAgIG5vdzogbm93MiA9IG5vdyxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDQsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXMsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlLFxuICAgIHRvb2xDYWxsU3RyZWFtaW5nLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtID09IG51bGwgPyB2b2lkIDAgOiB0cmFuc2Zvcm0oeyB0b29scyB9KSxcbiAgICBhY3RpdmVUb29scyxcbiAgICByZXBhaXJUb29sQ2FsbCxcbiAgICBtYXhTdGVwcyxcbiAgICBjb250aW51ZVN0ZXBzLFxuICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgb25DaHVuayxcbiAgICBvbkZpbmlzaCxcbiAgICBvblN0ZXBGaW5pc2gsXG4gICAgbm93OiBub3cyLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzXG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1UZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2UsXG4gICAgdG9vbENhbGxTdHJlYW1pbmcsXG4gICAgdHJhbnNmb3JtLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIG1heFN0ZXBzLFxuICAgIGNvbnRpbnVlU3RlcHMsXG4gICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICBvbkNodW5rLFxuICAgIG9uRmluaXNoLFxuICAgIG9uU3RlcEZpbmlzaCxcbiAgICBub3c6IG5vdzIsXG4gICAgY3VycmVudERhdGUsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDNcbiAgfSkge1xuICAgIHRoaXMud2FybmluZ3NQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy51c2FnZVByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvblByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy50ZXh0UHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbENhbGxzUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbFJlc3VsdHNQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5yZXF1ZXN0UHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMucmVzcG9uc2VQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5zdGVwc1Byb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICBpZiAobWF4U3RlcHMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4U3RlcHNcIixcbiAgICAgICAgdmFsdWU6IG1heFN0ZXBzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFN0ZXBzIG11c3QgYmUgYXQgbGVhc3QgMVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHJlY29yZGVkU3RlcFRleHQgPSBcIlwiO1xuICAgIGxldCByZWNvcmRlZENvbnRpbnVhdGlvblRleHQgPSBcIlwiO1xuICAgIGxldCByZWNvcmRlZEZ1bGxUZXh0ID0gXCJcIjtcbiAgICBsZXQgcmVjb3JkZWRSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIGNvbnN0IHJlY29yZGVkUmVzcG9uc2UgPSB7XG4gICAgICBpZDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgIHRpbWVzdGFtcDogY3VycmVudERhdGUoKSxcbiAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWQsXG4gICAgICBtZXNzYWdlczogW11cbiAgICB9O1xuICAgIGxldCByZWNvcmRlZFRvb2xDYWxscyA9IFtdO1xuICAgIGxldCByZWNvcmRlZFRvb2xSZXN1bHRzID0gW107XG4gICAgbGV0IHJlY29yZGVkRmluaXNoUmVhc29uID0gdm9pZCAwO1xuICAgIGxldCByZWNvcmRlZFVzYWdlID0gdm9pZCAwO1xuICAgIGxldCByZWNvcmRlZFByb3ZpZGVyTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgbGV0IHN0ZXBUeXBlID0gXCJpbml0aWFsXCI7XG4gICAgY29uc3QgcmVjb3JkZWRTdGVwcyA9IFtdO1xuICAgIGxldCByb290U3BhbjtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIiB8fCBjaHVuay50eXBlID09PSBcInRvb2wtY2FsbFwiIHx8IGNodW5rLnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiB8fCBjaHVuay50eXBlID09PSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIiB8fCBjaHVuay50eXBlID09PSBcInRvb2wtY2FsbC1kZWx0YVwiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuayB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRTdGVwVGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgcmVjb3JkZWRDb250aW51YXRpb25UZXh0ICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICByZWNvcmRlZEZ1bGxUZXh0ICs9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0b29sLWNhbGxcIikge1xuICAgICAgICAgIHJlY29yZGVkVG9vbENhbGxzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICByZWNvcmRlZFRvb2xSZXN1bHRzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInN0ZXAtZmluaXNoXCIpIHtcbiAgICAgICAgICBjb25zdCBzdGVwTWVzc2FnZXMgPSB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgdGV4dDogcmVjb3JkZWRDb250aW51YXRpb25UZXh0LFxuICAgICAgICAgICAgdG9vbHM6IHRvb2xzICE9IG51bGwgPyB0b29scyA6IHt9LFxuICAgICAgICAgICAgdG9vbENhbGxzOiByZWNvcmRlZFRvb2xDYWxscyxcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzOiByZWNvcmRlZFRvb2xSZXN1bHRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudFN0ZXAgPSByZWNvcmRlZFN0ZXBzLmxlbmd0aDtcbiAgICAgICAgICBsZXQgbmV4dFN0ZXBUeXBlID0gXCJkb25lXCI7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTdGVwICsgMSA8IG1heFN0ZXBzKSB7XG4gICAgICAgICAgICBpZiAoY29udGludWVTdGVwcyAmJiBjaHVuay5maW5pc2hSZWFzb24gPT09IFwibGVuZ3RoXCIgJiYgLy8gb25seSB1c2UgY29udGludWUgd2hlbiB0aGVyZSBhcmUgbm8gdG9vbCBjYWxsczpcbiAgICAgICAgICAgIHJlY29yZGVkVG9vbENhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAvLyB0aGVyZSBhcmUgdG9vbCBjYWxsczpcbiAgICAgICAgICAgICAgcmVjb3JkZWRUb29sQ2FsbHMubGVuZ3RoID4gMCAmJiAvLyBhbGwgY3VycmVudCB0b29sIGNhbGxzIGhhdmUgcmVzdWx0czpcbiAgICAgICAgICAgICAgcmVjb3JkZWRUb29sUmVzdWx0cy5sZW5ndGggPT09IHJlY29yZGVkVG9vbENhbGxzLmxlbmd0aFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwidG9vbC1yZXN1bHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGVwVHlwZSxcbiAgICAgICAgICAgIHRleHQ6IHJlY29yZGVkU3RlcFRleHQsXG4gICAgICAgICAgICB0b29sQ2FsbHM6IHJlY29yZGVkVG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHJlY29yZGVkVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIHVzYWdlOiBjaHVuay51c2FnZSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiBjaHVuay53YXJuaW5ncyxcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBjaHVuay5sb2dwcm9icyxcbiAgICAgICAgICAgIHJlcXVlc3Q6IGNodW5rLnJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAuLi5jaHVuay5yZXNwb25zZSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IFsuLi5yZWNvcmRlZFJlc3BvbnNlLm1lc3NhZ2VzLCAuLi5zdGVwTWVzc2FnZXNdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IGNodW5rLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgaXNDb250aW51ZWQ6IGNodW5rLmlzQ29udGludWVkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goY3VycmVudFN0ZXBSZXN1bHQpKTtcbiAgICAgICAgICByZWNvcmRlZFN0ZXBzLnB1c2goY3VycmVudFN0ZXBSZXN1bHQpO1xuICAgICAgICAgIHJlY29yZGVkVG9vbENhbGxzID0gW107XG4gICAgICAgICAgcmVjb3JkZWRUb29sUmVzdWx0cyA9IFtdO1xuICAgICAgICAgIHJlY29yZGVkU3RlcFRleHQgPSBcIlwiO1xuICAgICAgICAgIHJlY29yZGVkUmVxdWVzdCA9IGNodW5rLnJlcXVlc3Q7XG4gICAgICAgICAgaWYgKG5leHRTdGVwVHlwZSAhPT0gXCJkb25lXCIpIHtcbiAgICAgICAgICAgIHN0ZXBUeXBlID0gbmV4dFN0ZXBUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dFN0ZXBUeXBlICE9PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICAgIHJlY29yZGVkUmVzcG9uc2UubWVzc2FnZXMucHVzaCguLi5zdGVwTWVzc2FnZXMpO1xuICAgICAgICAgICAgcmVjb3JkZWRDb250aW51YXRpb25UZXh0ID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwiZmluaXNoXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLmlkID0gY2h1bmsucmVzcG9uc2UuaWQ7XG4gICAgICAgICAgcmVjb3JkZWRSZXNwb25zZS50aW1lc3RhbXAgPSBjaHVuay5yZXNwb25zZS50aW1lc3RhbXA7XG4gICAgICAgICAgcmVjb3JkZWRSZXNwb25zZS5tb2RlbElkID0gY2h1bmsucmVzcG9uc2UubW9kZWxJZDtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlLmhlYWRlcnMgPSBjaHVuay5yZXNwb25zZS5oZWFkZXJzO1xuICAgICAgICAgIHJlY29yZGVkVXNhZ2UgPSBjaHVuay51c2FnZTtcbiAgICAgICAgICByZWNvcmRlZEZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICByZWNvcmRlZFByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdmFyIF9hMTM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbGFzdFN0ZXAgPSByZWNvcmRlZFN0ZXBzW3JlY29yZGVkU3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3RTdGVwKSB7XG4gICAgICAgICAgICBzZWxmLndhcm5pbmdzUHJvbWlzZS5yZXNvbHZlKGxhc3RTdGVwLndhcm5pbmdzKTtcbiAgICAgICAgICAgIHNlbGYucmVxdWVzdFByb21pc2UucmVzb2x2ZShsYXN0U3RlcC5yZXF1ZXN0KTtcbiAgICAgICAgICAgIHNlbGYucmVzcG9uc2VQcm9taXNlLnJlc29sdmUobGFzdFN0ZXAucmVzcG9uc2UpO1xuICAgICAgICAgICAgc2VsZi50b29sQ2FsbHNQcm9taXNlLnJlc29sdmUobGFzdFN0ZXAudG9vbENhbGxzKTtcbiAgICAgICAgICAgIHNlbGYudG9vbFJlc3VsdHNQcm9taXNlLnJlc29sdmUobGFzdFN0ZXAudG9vbFJlc3VsdHMpO1xuICAgICAgICAgICAgc2VsZi5wcm92aWRlck1ldGFkYXRhUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgICBsYXN0U3RlcC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmluaXNoUmVhc29uID0gcmVjb3JkZWRGaW5pc2hSZWFzb24gIT0gbnVsbCA/IHJlY29yZGVkRmluaXNoUmVhc29uIDogXCJ1bmtub3duXCI7XG4gICAgICAgICAgY29uc3QgdXNhZ2UgPSByZWNvcmRlZFVzYWdlICE9IG51bGwgPyByZWNvcmRlZFVzYWdlIDoge1xuICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBOYU4sXG4gICAgICAgICAgICB0b3RhbFRva2VuczogTmFOXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZWxmLmZpbmlzaFJlYXNvblByb21pc2UucmVzb2x2ZShmaW5pc2hSZWFzb24pO1xuICAgICAgICAgIHNlbGYudXNhZ2VQcm9taXNlLnJlc29sdmUodXNhZ2UpO1xuICAgICAgICAgIHNlbGYudGV4dFByb21pc2UucmVzb2x2ZShyZWNvcmRlZEZ1bGxUZXh0KTtcbiAgICAgICAgICBzZWxmLnN0ZXBzUHJvbWlzZS5yZXNvbHZlKHJlY29yZGVkU3RlcHMpO1xuICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgbG9ncHJvYnM6IHZvaWQgMCxcbiAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgdGV4dDogcmVjb3JkZWRGdWxsVGV4dCxcbiAgICAgICAgICAgIHRvb2xDYWxsczogbGFzdFN0ZXAudG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IGxhc3RTdGVwLnRvb2xSZXN1bHRzLFxuICAgICAgICAgICAgcmVxdWVzdDogKF9hMTMgPSBsYXN0U3RlcC5yZXF1ZXN0KSAhPSBudWxsID8gX2ExMyA6IHt9LFxuICAgICAgICAgICAgcmVzcG9uc2U6IGxhc3RTdGVwLnJlc3BvbnNlLFxuICAgICAgICAgICAgd2FybmluZ3M6IGxhc3RTdGVwLndhcm5pbmdzLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IGxhc3RTdGVwLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgc3RlcHM6IHJlY29yZGVkU3RlcHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcm9vdFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiByZWNvcmRlZEZ1bGxUZXh0IH0sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTE0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChfYTE0ID0gbGFzdFN0ZXAudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNC5sZW5ndGgpID8gSlNPTi5zdHJpbmdpZnkobGFzdFN0ZXAudG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogdXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcm9vdFNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdGl0Y2hhYmxlU3RyZWFtID0gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpO1xuICAgIHRoaXMuYWRkU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5hZGRTdHJlYW07XG4gICAgdGhpcy5jbG9zZVN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uY2xvc2U7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gKHRyYW5zZm9ybSA/IHN0aXRjaGFibGVTdHJlYW0uc3RyZWFtLnBpcGVUaHJvdWdoKHRyYW5zZm9ybSkgOiBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbSkucGlwZVRocm91Z2goZXZlbnRQcm9jZXNzb3IpO1xuICAgIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmdcbiAgICB9KTtcbiAgICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIG1vZGVsLFxuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgICB9KTtcbiAgICBjb25zdCBpbml0aWFsUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgICAgdG9vbHNcbiAgICB9KTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZWNvcmRTcGFuKHtcbiAgICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dFwiLFxuICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYWkuc2V0dGluZ3MubWF4U3RlcHNcIjogbWF4U3RlcHNcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0cmFjZXIsXG4gICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICBmbjogYXN5bmMgKHJvb3RTcGFuQXJnKSA9PiB7XG4gICAgICAgIHJvb3RTcGFuID0gcm9vdFNwYW5Bcmc7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgc3RlcFR5cGU6IHN0ZXBUeXBlMixcbiAgICAgICAgICBwcmV2aW91c1N0ZXBUZXh0LFxuICAgICAgICAgIGhhc0xlYWRpbmdXaGl0ZXNwYWNlXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBjb25zdCBwcm9tcHRGb3JtYXQgPSByZXNwb25zZU1lc3NhZ2VzLmxlbmd0aCA9PT0gMCA/IGluaXRpYWxQcm9tcHQudHlwZSA6IFwibWVzc2FnZXNcIjtcbiAgICAgICAgICBjb25zdCBzdGVwSW5wdXRNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgIC4uLmluaXRpYWxQcm9tcHQubWVzc2FnZXMsXG4gICAgICAgICAgICAuLi5yZXNwb25zZU1lc3NhZ2VzXG4gICAgICAgICAgXTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICAgIHR5cGU6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgICAgc3lzdGVtOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IG1vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiBcInJlZ3VsYXJcIixcbiAgICAgICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UoeyB0b29scywgdG9vbENob2ljZSwgYWN0aXZlVG9vbHMgfSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSwgcmVxdWVzdCB9LFxuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgICAgIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHByb21wdEZvcm1hdFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGUgbGFuZ3VhZ2UgbW9kZWwgbGV2ZWwgdG9vbHM6XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9hMTM7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYTEzID0gbW9kZS50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTMubWFwKCh0b29sMikgPT4gSlNPTi5zdHJpbmdpZnkodG9vbDIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gbW9kZS50b29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShtb2RlLnRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IHNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMikgPT4gKHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBub3cyKCksXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGJlZm9yZSB0aGUgY2FsbFxuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBwcm9tcHRGb3JtYXQsXG4gICAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRTdHJlYW0gPSBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgZ2VuZXJhdG9yU3RyZWFtOiBzdHJlYW0sXG4gICAgICAgICAgICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBzdGVwUmVxdWVzdCA9IHJlcXVlc3QgIT0gbnVsbCA/IHJlcXVlc3QgOiB7fTtcbiAgICAgICAgICBjb25zdCBzdGVwVG9vbENhbGxzID0gW107XG4gICAgICAgICAgY29uc3Qgc3RlcFRvb2xSZXN1bHRzID0gW107XG4gICAgICAgICAgbGV0IHN0ZXBGaW5pc2hSZWFzb24gPSBcInVua25vd25cIjtcbiAgICAgICAgICBsZXQgc3RlcFVzYWdlID0ge1xuICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogMCxcbiAgICAgICAgICAgIHRvdGFsVG9rZW5zOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsZXQgc3RlcFByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgbGV0IHN0ZXBGaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgICBsZXQgc3RlcFRleHQgPSBcIlwiO1xuICAgICAgICAgIGxldCBmdWxsU3RlcFRleHQgPSBzdGVwVHlwZTIgPT09IFwiY29udGludWVcIiA/IHByZXZpb3VzU3RlcFRleHQgOiBcIlwiO1xuICAgICAgICAgIGxldCBzdGVwTG9nUHJvYnM7XG4gICAgICAgICAgbGV0IHN0ZXBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgIH07XG4gICAgICAgICAgbGV0IGNodW5rQnVmZmVyID0gXCJcIjtcbiAgICAgICAgICBsZXQgY2h1bmtUZXh0UHVibGlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGluV2hpdGVzcGFjZVByZWZpeCA9IHRydWU7XG4gICAgICAgICAgbGV0IGhhc1doaXRlc3BhY2VTdWZmaXggPSBmYWxzZTtcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBwdWJsaXNoVGV4dENodW5rKHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICBjaHVua1xuICAgICAgICAgIH0pIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICBzdGVwVGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgICBmdWxsU3RlcFRleHQgKz0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgICAgY2h1bmtUZXh0UHVibGlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1doaXRlc3BhY2VTdWZmaXggPSBjaHVuay50ZXh0RGVsdGEudHJpbUVuZCgpICE9PSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuYWRkU3RyZWFtKFxuICAgICAgICAgICAgdHJhbnNmb3JtZWRTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgdmFyIF9hMTMsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgIGlmIChzdGVwRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIiAmJiBjaHVuay50ZXh0RGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRDaHVua1RleHQgPSBpbldoaXRlc3BhY2VQcmVmaXggJiYgaGFzTGVhZGluZ1doaXRlc3BhY2UgPyBjaHVuay50ZXh0RGVsdGEudHJpbVN0YXJ0KCkgOiBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpbW1lZENodW5rVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbldoaXRlc3BhY2VQcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rQnVmZmVyICs9IHRyaW1tZWRDaHVua1RleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpdCA9IHNwbGl0T25MYXN0V2hpdGVzcGFjZShjaHVua0J1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua0J1ZmZlciA9IHNwbGl0LnN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHNwbGl0LnByZWZpeCArIHNwbGl0LndoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciwgY2h1bmsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xSZXN1bHRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IChfYTEzID0gY2h1bmsuaWQpICE9IG51bGwgPyBfYTEzIDogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2IgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYiA6IHN0ZXBSZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2MgPSBjaHVuay5tb2RlbElkKSAhPSBudWxsID8gX2MgOiBzdGVwUmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwUHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBMb2dQcm9icyA9IGNodW5rLmxvZ3Byb2JzO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaW5pc2ggPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maW5pc2hcIik7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmluaXNoXCI6IG1zVG9GaW5pc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmF2Z0NvbXBsZXRpb25Ub2tlbnNQZXJTZWNvbmRcIjogMWUzICogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgLyBtc1RvRmluaXNoXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICAgICAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHNKc29uID0gc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV4dFN0ZXBUeXBlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0ZXAgKyAxIDwgbWF4U3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgc3RlcEZpbmlzaFJlYXNvbiA9PT0gXCJsZW5ndGhcIiAmJiAvLyBvbmx5IHVzZSBjb250aW51ZSB3aGVuIHRoZXJlIGFyZSBubyB0b29sIGNhbGxzOlxuICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbENhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBhcmUgdG9vbCBjYWxsczpcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xSZXN1bHRzLmxlbmd0aCA9PT0gc3RlcFRvb2xDYWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJ0b29sLXJlc3VsdFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGludWVTdGVwcyAmJiBjaHVua0J1ZmZlci5sZW5ndGggPiAwICYmIChuZXh0U3RlcFR5cGUgIT09IFwiY29udGludWVcIiB8fCAvLyB3aGVuIHRoZSBuZXh0IHN0ZXAgaXMgYSByZWd1bGFyIHN0ZXAsIHB1Ymxpc2ggdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgc3RlcFR5cGUyID09PSBcImNvbnRpbnVlXCIgJiYgIWNodW5rVGV4dFB1Ymxpc2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IGNodW5rQnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gc3RlcFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHN0ZXBSZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogc3RlcFVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtzdGVwRmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiBzdGVwUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1maW5pc2hcIixcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZTogc3RlcFVzYWdlLFxuICAgICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHN0ZXBSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLnN0ZXBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgaXNDb250aW51ZWQ6IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkVXNhZ2UgPSBhZGRMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UsIHN0ZXBVc2FnZSk7XG4gICAgICAgICAgICAgICAgICBpZiAobmV4dFN0ZXBUeXBlID09PSBcImRvbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOiBjb21iaW5lZFVzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBsb2dwcm9iczogc3RlcExvZ1Byb2JzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwVHlwZTIgPT09IFwiY29udGludWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gcmVzcG9uc2VNZXNzYWdlc1tyZXNwb25zZU1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdE1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudCArPSBzdGVwVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xzOiB0b29scyAhPSBudWxsID8gdG9vbHMgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0czogc3RlcFRvb2xSZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RyZWFtU3RlcCh7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IGN1cnJlbnRTdGVwICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOiBjb21iaW5lZFVzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBUeXBlOiBuZXh0U3RlcFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNTdGVwVGV4dDogZnVsbFN0ZXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIGhhc0xlYWRpbmdXaGl0ZXNwYWNlOiBoYXNXaGl0ZXNwYWNlU3VmZml4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwOiAwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXM6IFtdLFxuICAgICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgICBwcm9tcHRUb2tlbnM6IDAsXG4gICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZpb3VzU3RlcFRleHQ6IFwiXCIsXG4gICAgICAgICAgc3RlcFR5cGU6IFwiaW5pdGlhbFwiLFxuICAgICAgICAgIGhhc0xlYWRpbmdXaGl0ZXNwYWNlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIHNlbGYuYWRkU3RyZWFtKFxuICAgICAgICBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMud2FybmluZ3NQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy51c2FnZVByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hSZWFzb25Qcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck1ldGFkYXRhUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0UHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xDYWxsc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xSZXN1bHRzUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcmVxdWVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2VQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBzdGVwcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgLyoqXG4gIFNwbGl0IG91dCBhIG5ldyBzdHJlYW0gZnJvbSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBUaGUgb3JpZ2luYWwgc3RyZWFtIGlzIHJlcGxhY2VkIHRvIGFsbG93IGZvciBmdXJ0aGVyIHNwbGl0dGluZyxcbiAgc2luY2Ugd2UgZG8gbm90IGtub3cgaG93IG1hbnkgdGltZXMgdGhlIHN0cmVhbSB3aWxsIGJlIHNwbGl0LlxuICBcbiAgTm90ZTogdGhpcyBsZWFkcyB0byBidWZmZXJpbmcgdGhlIHN0cmVhbSBjb250ZW50IG9uIHRoZSBzZXJ2ZXIuXG4gIEhvd2V2ZXIsIHRoZSBMTE0gcmVzdWx0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgc21hbGwgZW5vdWdoIHRvIG5vdCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gIHRlZVN0cmVhbSgpIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSB0aGlzLmJhc2VTdHJlYW0udGVlKCk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtMjtcbiAgICByZXR1cm4gc3RyZWFtMTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy50ZWVTdHJlYW0oKSk7XG4gIH1cbiAgdG9EYXRhU3RyZWFtSW50ZXJuYWwoe1xuICAgIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlNSA9ICgpID0+IFwiQW4gZXJyb3Igb2NjdXJyZWQuXCIsXG4gICAgLy8gbWFzayBlcnJvciBtZXNzYWdlcyBmb3Igc2FmZXR5IGJ5IGRlZmF1bHRcbiAgICBzZW5kVXNhZ2UgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICAgIGNvbnN0IGNhbGxiYWNrVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3RyZWFtUGFydHNUcmFuc2Zvcm1lciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwidGV4dFwiLCBjaHVuay50ZXh0RGVsdGEpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJ0b29sX2NhbGxfZGVsdGFcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0RGF0YVN0cmVhbVBhcnQyKFwidG9vbF9jYWxsXCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBjaHVuay5hcmdzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcInRvb2xfcmVzdWx0XCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogY2h1bmsucmVzdWx0XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdERhdGFTdHJlYW1QYXJ0MihcImVycm9yXCIsIGdldEVycm9yTWVzc2FnZTUoY2h1bmsuZXJyb3IpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwic3RlcC1maW5pc2hcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJmaW5pc2hfc3RlcFwiLCB7XG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHNlbmRVc2FnZSA/IHtcbiAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogY2h1bmsudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgaXNDb250aW51ZWQ6IGNodW5rLmlzQ29udGludWVkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXREYXRhU3RyZWFtUGFydDIoXCJmaW5pc2hfbWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHNlbmRVc2FnZSA/IHtcbiAgICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogY2h1bmsudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgIH0gOiB2b2lkIDBcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZ1bGxTdHJlYW0ucGlwZVRocm91Z2goY2FsbGJhY2tUcmFuc2Zvcm1lcikucGlwZVRocm91Z2goc3RyZWFtUGFydHNUcmFuc2Zvcm1lcik7XG4gIH1cbiAgcGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVycyxcbiAgICBkYXRhLFxuICAgIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlNSxcbiAgICBzZW5kVXNhZ2VcbiAgfSA9IHt9KSB7XG4gICAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50b0RhdGFTdHJlYW0oeyBkYXRhLCBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTUsIHNlbmRVc2FnZSB9KVxuICAgIH0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHN0YXR1czogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlT3V0Z29pbmdIdHRwSGVhZGVycyhpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG4gIC8vIFRPRE8gYnJlYWtpbmcgY2hhbmdlIDUuMDogcmVtb3ZlIHBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICB0b0RhdGFTdHJlYW0ob3B0aW9ucykge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMudG9EYXRhU3RyZWFtSW50ZXJuYWwoe1xuICAgICAgZ2V0RXJyb3JNZXNzYWdlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldEVycm9yTWVzc2FnZSxcbiAgICAgIHNlbmRVc2FnZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zZW5kVXNhZ2VcbiAgICB9KS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpID8gbWVyZ2VTdHJlYW1zKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YS5zdHJlYW0sIHN0cmVhbSkgOiBzdHJlYW07XG4gIH1cbiAgbWVyZ2VJbnRvRGF0YVN0cmVhbSh3cml0ZXIpIHtcbiAgICB3cml0ZXIubWVyZ2UoXG4gICAgICB0aGlzLnRvRGF0YVN0cmVhbUludGVybmFsKHtcbiAgICAgICAgZ2V0RXJyb3JNZXNzYWdlOiB3cml0ZXIub25FcnJvclxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlKHtcbiAgICBoZWFkZXJzLFxuICAgIHN0YXR1cyxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGRhdGEsXG4gICAgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2U1LFxuICAgIHNlbmRVc2FnZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgdGhpcy50b0RhdGFTdHJlYW0oeyBkYXRhLCBnZXRFcnJvck1lc3NhZ2U6IGdldEVycm9yTWVzc2FnZTUsIHNlbmRVc2FnZSB9KSxcbiAgICAgIHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgICAgZGF0YVN0cmVhbVZlcnNpb246IFwidjFcIlxuICAgICAgICB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTEzO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgICAgc3RhdHVzOiAoX2ExMyA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMyA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3Ntb290aC1zdHJlYW0udHNcbmZ1bmN0aW9uIHNtb290aFN0cmVhbSh7XG4gIGRlbGF5SW5NcyA9IDEwLFxuICBfaW50ZXJuYWw6IHsgZGVsYXk6IGRlbGF5MiA9IGRlbGF5IH0gPSB7fVxufSA9IHt9KSB7XG4gIGxldCBidWZmZXIgPSBcIlwiO1xuICByZXR1cm4gKCkgPT4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJzdGVwLWZpbmlzaFwiKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGE6IGJ1ZmZlciB9KTtcbiAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuay50eXBlICE9PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBidWZmZXIgKz0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgd2hpbGUgKGJ1ZmZlci5tYXRjaCgvXFxzLykpIHtcbiAgICAgICAgY29uc3Qgd2hpdGVzcGFjZUluZGV4ID0gYnVmZmVyLnNlYXJjaCgvXFxzLyk7XG4gICAgICAgIGNvbnN0IHdvcmQgPSBidWZmZXIuc2xpY2UoMCwgd2hpdGVzcGFjZUluZGV4ICsgMSk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGE6IHdvcmQgfSk7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSh3aGl0ZXNwYWNlSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKGRlbGF5SW5NcyA+IDApIHtcbiAgICAgICAgICBhd2FpdCBkZWxheTIoZGVsYXlJbk1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIGNvcmUvbWlkZGxld2FyZS93cmFwLWxhbmd1YWdlLW1vZGVsLnRzXG52YXIgZXhwZXJpbWVudGFsX3dyYXBMYW5ndWFnZU1vZGVsID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IHsgdHJhbnNmb3JtUGFyYW1zLCB3cmFwR2VuZXJhdGUsIHdyYXBTdHJlYW0gfSxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICBhc3luYyBmdW5jdGlvbiBkb1RyYW5zZm9ybSh7XG4gICAgcGFyYW1zLFxuICAgIHR5cGVcbiAgfSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYXJhbXMgPyBhd2FpdCB0cmFuc2Zvcm1QYXJhbXMoeyBwYXJhbXMsIHR5cGUgfSkgOiBwYXJhbXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2MVwiLFxuICAgIHByb3ZpZGVyOiBwcm92aWRlcklkICE9IG51bGwgPyBwcm92aWRlcklkIDogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWxJZCAhPSBudWxsID8gbW9kZWxJZCA6IG1vZGVsLm1vZGVsSWQsXG4gICAgZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlOiBtb2RlbC5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGUsXG4gICAgc3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgIHN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybCxcbiAgICBzdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzOiBtb2RlbC5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzLFxuICAgIGFzeW5jIGRvR2VuZXJhdGUocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zLCB0eXBlOiBcImdlbmVyYXRlXCIgfSk7XG4gICAgICBjb25zdCBkb0dlbmVyYXRlID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcEdlbmVyYXRlID8gd3JhcEdlbmVyYXRlKHsgZG9HZW5lcmF0ZSwgcGFyYW1zOiB0cmFuc2Zvcm1lZFBhcmFtcywgbW9kZWwgfSkgOiBkb0dlbmVyYXRlKCk7XG4gICAgfSxcbiAgICBhc3luYyBkb1N0cmVhbShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMsIHR5cGU6IFwic3RyZWFtXCIgfSk7XG4gICAgICBjb25zdCBkb1N0cmVhbSA9IGFzeW5jICgpID0+IG1vZGVsLmRvU3RyZWFtKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIHJldHVybiB3cmFwU3RyZWFtID8gd3JhcFN0cmVhbSh7IGRvU3RyZWFtLCBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zLCBtb2RlbCB9KSA6IGRvU3RyZWFtKCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gY29yZS9yZWdpc3RyeS9jdXN0b20tcHJvdmlkZXIudHNcbmltcG9ydCB7IE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyKHtcbiAgbGFuZ3VhZ2VNb2RlbHMsXG4gIHRleHRFbWJlZGRpbmdNb2RlbHMsXG4gIGZhbGxiYWNrUHJvdmlkZXJcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBsYW5ndWFnZU1vZGVsKG1vZGVsSWQpIHtcbiAgICAgIGlmIChsYW5ndWFnZU1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gbGFuZ3VhZ2VNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTW9kZWxzW21vZGVsSWRdO1xuICAgICAgfVxuICAgICAgaWYgKGZhbGxiYWNrUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIgfSk7XG4gICAgfSxcbiAgICB0ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHRleHRFbWJlZGRpbmdNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHRleHRFbWJlZGRpbmdNb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIHRleHRFbWJlZGRpbmdNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwidGV4dEVtYmVkZGluZ01vZGVsXCIgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBjb3JlL3JlZ2lzdHJ5L25vLXN1Y2gtcHJvdmlkZXItZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjEzLCBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTIgPSBcIkFJX05vU3VjaFByb3ZpZGVyRXJyb3JcIjtcbnZhciBtYXJrZXIxMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTJ9YDtcbnZhciBzeW1ib2wxMiA9IFN5bWJvbC5mb3IobWFya2VyMTIpO1xudmFyIF9hMTI7XG52YXIgTm9TdWNoUHJvdmlkZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgTm9TdWNoTW9kZWxFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgcHJvdmlkZXJJZCxcbiAgICBhdmFpbGFibGVQcm92aWRlcnMsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoIHByb3ZpZGVyOiAke3Byb3ZpZGVySWR9IChhdmFpbGFibGUgcHJvdmlkZXJzOiAke2F2YWlsYWJsZVByb3ZpZGVycy5qb2luKCl9KWBcbiAgfSkge1xuICAgIHN1cGVyKHsgZXJyb3JOYW1lOiBuYW1lMTIsIG1vZGVsSWQsIG1vZGVsVHlwZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTJdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgIHRoaXMuYXZhaWxhYmxlUHJvdmlkZXJzID0gYXZhaWxhYmxlUHJvdmlkZXJzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEyKTtcbiAgfVxufTtcbl9hMTIgPSBzeW1ib2wxMjtcblxuLy8gY29yZS9yZWdpc3RyeS9wcm92aWRlci1yZWdpc3RyeS50c1xuaW1wb3J0IHsgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeShwcm92aWRlcnMpIHtcbiAgY29uc3QgcmVnaXN0cnkgPSBuZXcgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkoKTtcbiAgZm9yIChjb25zdCBbaWQsIHByb3ZpZGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpKSB7XG4gICAgcmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KTtcbiAgfVxuICByZXR1cm4gcmVnaXN0cnk7XG59XG52YXIgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvdmlkZXJzID0ge307XG4gIH1cbiAgcmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KSB7XG4gICAgdGhpcy5wcm92aWRlcnNbaWRdID0gcHJvdmlkZXI7XG4gIH1cbiAgZ2V0UHJvdmlkZXIoaWQpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzW2lkXTtcbiAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaFByb3ZpZGVyRXJyb3Ioe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIixcbiAgICAgICAgcHJvdmlkZXJJZDogaWQsXG4gICAgICAgIGF2YWlsYWJsZVByb3ZpZGVyczogT2JqZWN0LmtleXModGhpcy5wcm92aWRlcnMpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xuICB9XG4gIHNwbGl0SWQoaWQsIG1vZGVsVHlwZSkge1xuICAgIGNvbnN0IGluZGV4ID0gaWQuaW5kZXhPZihcIjpcIik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZSxcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgJHttb2RlbFR5cGV9IGlkIGZvciByZWdpc3RyeTogJHtpZH0gKG11c3QgYmUgaW4gdGhlIGZvcm1hdCBcInByb3ZpZGVySWQ6bW9kZWxJZFwiKWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lkLnNsaWNlKDAsIGluZGV4KSwgaWQuc2xpY2UoaW5kZXggKyAxKV07XG4gIH1cbiAgbGFuZ3VhZ2VNb2RlbChpZCkge1xuICAgIHZhciBfYTEzLCBfYjtcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwibGFuZ3VhZ2VNb2RlbFwiKTtcbiAgICBjb25zdCBtb2RlbCA9IChfYiA9IChfYTEzID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkKSkubGFuZ3VhZ2VNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2ExMywgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdGV4dEVtYmVkZGluZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTM7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInRleHRFbWJlZGRpbmdNb2RlbFwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCk7XG4gICAgY29uc3QgbW9kZWwgPSAoX2ExMyA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTMuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwidGV4dEVtYmVkZGluZ01vZGVsXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgdGV4dEVtYmVkZGluZ01vZGVsYCBpbnN0ZWFkLlxuICAgKi9cbiAgdGV4dEVtYmVkZGluZyhpZCkge1xuICAgIHJldHVybiB0aGlzLnRleHRFbWJlZGRpbmdNb2RlbChpZCk7XG4gIH1cbn07XG5cbi8vIGNvcmUvdG9vbC90b29sLnRzXG5mdW5jdGlvbiB0b29sKHRvb2wyKSB7XG4gIHJldHVybiB0b29sMjtcbn1cblxuLy8gY29yZS91dGlsL2Nvc2luZS1zaW1pbGFyaXR5LnRzXG5mdW5jdGlvbiBjb3NpbmVTaW1pbGFyaXR5KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBWZWN0b3JzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGggKHZlY3RvcjE6ICR7dmVjdG9yMS5sZW5ndGh9IGVsZW1lbnRzLCB2ZWN0b3IyOiAke3ZlY3RvcjIubGVuZ3RofSBlbGVtZW50cylgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZG90UHJvZHVjdCh2ZWN0b3IxLCB2ZWN0b3IyKSAvIChtYWduaXR1ZGUodmVjdG9yMSkgKiBtYWduaXR1ZGUodmVjdG9yMikpO1xufVxuZnVuY3Rpb24gZG90UHJvZHVjdCh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIHJldHVybiB2ZWN0b3IxLnJlZHVjZShcbiAgICAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCkgPT4gYWNjdW11bGF0b3IgKyB2YWx1ZSAqIHZlY3RvcjJbaW5kZXhdLFxuICAgIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIG1hZ25pdHVkZSh2ZWN0b3IpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkb3RQcm9kdWN0KHZlY3RvciwgdmVjdG9yKSk7XG59XG5cbi8vIHN0cmVhbXMvYXNzaXN0YW50LXJlc3BvbnNlLnRzXG5pbXBvcnQge1xuICBmb3JtYXRBc3Npc3RhbnRTdHJlYW1QYXJ0XG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBBc3Npc3RhbnRSZXNwb25zZSh7IHRocmVhZElkLCBtZXNzYWdlSWQgfSwgcHJvY2VzczIpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2ExMztcbiAgICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRBc3Npc3RhbnRTdHJlYW1QYXJ0KFwiYXNzaXN0YW50X21lc3NhZ2VcIiwgbWVzc2FnZSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZERhdGFNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQoXCJkYXRhX21lc3NhZ2VcIiwgbWVzc2FnZSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZEVycm9yID0gKGVycm9yTWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQoXCJlcnJvclwiLCBlcnJvck1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBhc3luYyAoc3RyZWFtMikgPT4ge1xuICAgICAgICB2YXIgX2ExNCwgX2I7XG4gICAgICAgIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtMikge1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQubWVzc2FnZS5jcmVhdGVkXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogeyB2YWx1ZTogXCJcIiB9IH1dXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9hMTQgPSB2YWx1ZS5kYXRhLmRlbHRhLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTE0WzBdO1xuICAgICAgICAgICAgICBpZiAoKGNvbnRlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRlbnQudHlwZSkgPT09IFwidGV4dFwiICYmICgoX2IgPSBjb250ZW50LnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYi52YWx1ZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydChcInRleHRcIiwgY29udGVudC50ZXh0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLnJ1bi5jb21wbGV0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvblwiOiB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQoXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsIHtcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3MyKHtcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBzZW5kRGF0YU1lc3NhZ2UsXG4gICAgICAgICAgZm9yd2FyZFN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNlbmRFcnJvcigoX2ExMyA9IGVycm9yLm1lc3NhZ2UpICE9IG51bGwgPyBfYTEzIDogYCR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tYWRhcHRlci50c1xudmFyIGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMsIHtcbiAgbWVyZ2VJbnRvRGF0YVN0cmVhbTogKCkgPT4gbWVyZ2VJbnRvRGF0YVN0cmVhbSxcbiAgdG9EYXRhU3RyZWFtOiAoKSA9PiB0b0RhdGFTdHJlYW0sXG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlOiAoKSA9PiB0b0RhdGFTdHJlYW1SZXNwb25zZVxufSk7XG5pbXBvcnQgeyBmb3JtYXREYXRhU3RyZWFtUGFydCBhcyBmb3JtYXREYXRhU3RyZWFtUGFydDMgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyBzdHJlYW1zL3N0cmVhbS1jYWxsYmFja3MudHNcbmZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcyA9IHt9KSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShtZXNzYWdlKSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4obWVzc2FnZSk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1hZGFwdGVyLnRzXG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1JbnRlcm5hbChzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAodmFsdWUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgdmFyIF9hMTM7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJldmVudFwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmV2ZW50ID09PSBcIm9uX2NoYXRfbW9kZWxfc3RyZWFtXCIpIHtcbiAgICAgICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayhcbiAgICAgICAgICAgICAgKF9hMTMgPSB2YWx1ZS5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMy5jaHVuayxcbiAgICAgICAgICAgICAgY29udHJvbGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayh2YWx1ZSwgY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSlcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQzKFwidGV4dFwiLCBjaHVuaykpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHRvRGF0YVN0cmVhbUludGVybmFsKHN0cmVhbSwgY2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVGV4dEVuY29kZXJTdHJlYW0oKVxuICApO1xufVxuZnVuY3Rpb24gdG9EYXRhU3RyZWFtUmVzcG9uc2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gIHZhciBfYTEzO1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtSW50ZXJuYWwoXG4gICAgc3RyZWFtLFxuICAgIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FsbGJhY2tzXG4gICkucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xuICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhO1xuICBjb25zdCBpbml0ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbml0O1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTMgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTMgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZUludG9EYXRhU3RyZWFtKHN0cmVhbSwgb3B0aW9ucykge1xuICBvcHRpb25zLmRhdGFTdHJlYW0ubWVyZ2UodG9EYXRhU3RyZWFtSW50ZXJuYWwoc3RyZWFtLCBvcHRpb25zLmNhbGxiYWNrcykpO1xufVxuZnVuY3Rpb24gZm9yd2FyZEFJTWVzc2FnZUNodW5rKGNodW5rLCBjb250cm9sbGVyKSB7XG4gIGlmICh0eXBlb2YgY2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5jb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50ID0gY2h1bmsuY29udGVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29udGVudCkge1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGl0ZW0udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHN0cmVhbXMvbGxhbWFpbmRleC1hZGFwdGVyLnRzXG52YXIgbGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxsYW1haW5kZXhfYWRhcHRlcl9leHBvcnRzLCB7XG4gIG1lcmdlSW50b0RhdGFTdHJlYW06ICgpID0+IG1lcmdlSW50b0RhdGFTdHJlYW0yLFxuICB0b0RhdGFTdHJlYW06ICgpID0+IHRvRGF0YVN0cmVhbTIsXG4gIHRvRGF0YVN0cmVhbVJlc3BvbnNlOiAoKSA9PiB0b0RhdGFTdHJlYW1SZXNwb25zZTJcbn0pO1xuaW1wb3J0IHsgY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGZvcm1hdERhdGFTdHJlYW1QYXJ0IGFzIGZvcm1hdERhdGFTdHJlYW1QYXJ0NCB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1JbnRlcm5hbDIoc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgY29uc3QgdHJpbVN0YXJ0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oKTtcbiAgcmV0dXJuIGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbShzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRyaW1TdGFydChtZXNzYWdlLmRlbHRhKSk7XG4gICAgICB9XG4gICAgfSlcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0RGF0YVN0cmVhbVBhcnQ0KFwidGV4dFwiLCBjaHVuaykpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW0yKHN0cmVhbSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiB0b0RhdGFTdHJlYW1JbnRlcm5hbDIoc3RyZWFtLCBjYWxsYmFja3MpLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpXG4gICk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1SZXNwb25zZTIoc3RyZWFtLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hMTM7XG4gIGNvbnN0IHsgaW5pdCwgZGF0YSwgY2FsbGJhY2tzIH0gPSBvcHRpb25zO1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtSW50ZXJuYWwyKHN0cmVhbSwgY2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVGV4dEVuY29kZXJTdHJlYW0oKVxuICApO1xuICBjb25zdCByZXNwb25zZVN0cmVhbSA9IGRhdGEgPyBtZXJnZVN0cmVhbXMoZGF0YS5zdHJlYW0sIGRhdGFTdHJlYW0pIDogZGF0YVN0cmVhbTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZVN0cmVhbSwge1xuICAgIHN0YXR1czogKF9hMTMgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTMgOiAyMDAsXG4gICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZUludG9EYXRhU3RyZWFtMihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5kYXRhU3RyZWFtLm1lcmdlKHRvRGF0YVN0cmVhbUludGVybmFsMihzdHJlYW0sIG9wdGlvbnMuY2FsbGJhY2tzKSk7XG59XG5mdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbSgpIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuICByZXR1cm4gKHRleHQyKSA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQyID0gdGV4dDIudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dDIpXG4gICAgICAgIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQyO1xuICB9O1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG5pbXBvcnQgeyBmb3JtYXREYXRhU3RyZWFtUGFydCBhcyBmb3JtYXREYXRhU3RyZWFtUGFydDUgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2NvbnN0YW50cy50c1xudmFyIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyA9IDE1ICogMWUzO1xuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG52YXIgU3RyZWFtRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy53YXJuaW5nVGltZW91dCA9IG51bGw7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGFzeW5jIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgc2VsZi53YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcIlRoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgP1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKHJlYXNvbikgPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShmb3JtYXREYXRhU3RyZWFtUGFydDUoXCJkYXRhXCIsIFt2YWx1ZV0pKVxuICAgICk7XG4gIH1cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdERhdGFTdHJlYW1QYXJ0NShcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgW3ZhbHVlXSkpXG4gICAgKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFJU0RLRXJyb3IxMiBhcyBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IyIGFzIEFQSUNhbGxFcnJvcixcbiAgQXNzaXN0YW50UmVzcG9uc2UsXG4gIERvd25sb2FkRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcixcbiAgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcjIgYXMgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzIGFzIExhbmdDaGFpbkFkYXB0ZXIsXG4gIGxsYW1haW5kZXhfYWRhcHRlcl9leHBvcnRzIGFzIExsYW1hSW5kZXhBZGFwdGVyLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBOb1N1Y2hQcm92aWRlckVycm9yLFxuICBOb1N1Y2hUb29sRXJyb3IsXG4gIG91dHB1dF9leHBvcnRzIGFzIE91dHB1dCxcbiAgUmV0cnlFcnJvcixcbiAgU3RyZWFtRGF0YSxcbiAgVG9vbENhbGxSZXBhaXJFcnJvcixcbiAgVG9vbEV4ZWN1dGlvbkVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yMiBhcyBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjIgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyxcbiAgY29zaW5lU2ltaWxhcml0eSxcbiAgY3JlYXRlRGF0YVN0cmVhbSxcbiAgY3JlYXRlRGF0YVN0cmVhbVJlc3BvbnNlLFxuICBlbWJlZCxcbiAgZW1iZWRNYW55LFxuICBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyLFxuICBnZW5lcmF0ZUltYWdlIGFzIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZUltYWdlLFxuICBleHBlcmltZW50YWxfd3JhcExhbmd1YWdlTW9kZWwsXG4gIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQyIGFzIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIGZvcm1hdERhdGFTdHJlYW1QYXJ0NiBhcyBmb3JtYXREYXRhU3RyZWFtUGFydCxcbiAgZ2VuZXJhdGVJZDIgYXMgZ2VuZXJhdGVJZCxcbiAgZ2VuZXJhdGVPYmplY3QsXG4gIGdlbmVyYXRlVGV4dCxcbiAganNvblNjaGVtYSxcbiAgcGFyc2VBc3Npc3RhbnRTdHJlYW1QYXJ0LFxuICBwYXJzZURhdGFTdHJlYW1QYXJ0LFxuICBwaXBlRGF0YVN0cmVhbVRvUmVzcG9uc2UsXG4gIHByb2Nlc3NEYXRhU3RyZWFtLFxuICBwcm9jZXNzVGV4dFN0cmVhbSxcbiAgc21vb3RoU3RyZWFtLFxuICBzdHJlYW1PYmplY3QsXG4gIHN0cmVhbVRleHQsXG4gIHRvb2xcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lMTMiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydCIsImZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQyIiwiZm9ybWF0RGF0YVN0cmVhbVBhcnQiLCJmb3JtYXREYXRhU3RyZWFtUGFydDYiLCJwYXJzZUFzc2lzdGFudFN0cmVhbVBhcnQiLCJwYXJzZURhdGFTdHJlYW1QYXJ0IiwicHJvY2Vzc0RhdGFTdHJlYW0iLCJwcm9jZXNzVGV4dFN0cmVhbSIsImdlbmVyYXRlSWQiLCJnZW5lcmF0ZUlkMiIsImpzb25TY2hlbWEiLCJjcmVhdGVEYXRhU3RyZWFtIiwiZXhlY3V0ZSIsIm9uRXJyb3IiLCJjb250cm9sbGVyIiwib25nb2luZ1N0cmVhbVByb21pc2VzIiwic3RyZWFtIiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXJBcmciLCJzYWZlRW5xdWV1ZSIsImRhdGEiLCJlbnF1ZXVlIiwiZXJyb3IiLCJyZXN1bHQiLCJ3cml0ZURhdGEiLCJ3cml0ZU1lc3NhZ2VBbm5vdGF0aW9uIiwiYW5ub3RhdGlvbiIsIm1lcmdlIiwic3RyZWFtQXJnIiwicHVzaCIsInJlYWRlciIsImdldFJlYWRlciIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJjYXRjaCIsIndhaXRGb3JTdHJlYW1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJsZW5ndGgiLCJzaGlmdCIsImZpbmFsbHkiLCJjbG9zZSIsInByZXBhcmVSZXNwb25zZUhlYWRlcnMiLCJoZWFkZXJzIiwiY29udGVudFR5cGUiLCJkYXRhU3RyZWFtVmVyc2lvbiIsInJlc3BvbnNlSGVhZGVycyIsIkhlYWRlcnMiLCJoYXMiLCJzZXQiLCJjcmVhdGVEYXRhU3RyZWFtUmVzcG9uc2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiUmVzcG9uc2UiLCJwaXBlVGhyb3VnaCIsIlRleHRFbmNvZGVyU3RyZWFtIiwicHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMiLCJvdXRnb2luZ0hlYWRlcnMiLCJrZXkiLCJlbnRyaWVzIiwid3JpdGVUb1NlcnZlclJlc3BvbnNlIiwicmVzcG9uc2UiLCJ3cml0ZUhlYWQiLCJ3cml0ZSIsImVuZCIsInBpcGVEYXRhU3RyZWFtVG9SZXNwb25zZSIsIkFJU0RLRXJyb3IiLCJuYW1lIiwibWFya2VyIiwic3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiX2EiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImNvbnN0cnVjdG9yIiwicGFyYW1ldGVyIiwibWVzc2FnZSIsImlzSW5zdGFuY2UiLCJoYXNNYXJrZXIiLCJBUElDYWxsRXJyb3IiLCJnZXRFcnJvck1lc3NhZ2UiLCJpc0Fib3J0RXJyb3IiLCJkZWxheSIsImRlbGF5SW5NcyIsInNldFRpbWVvdXQiLCJBSVNES0Vycm9yMiIsIm5hbWUyIiwibWFya2VyMiIsInN5bWJvbDIiLCJfYTIiLCJSZXRyeUVycm9yIiwicmVhc29uIiwiZXJyb3JzIiwibGFzdEVycm9yIiwicmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwibWF4UmV0cmllcyIsImluaXRpYWxEZWxheUluTXMiLCJiYWNrb2ZmRmFjdG9yIiwiZiIsIl9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYiLCJlcnJvck1lc3NhZ2UiLCJuZXdFcnJvcnMiLCJ0cnlOdW1iZXIiLCJFcnJvciIsImlzUmV0cnlhYmxlIiwicHJlcGFyZVJldHJpZXMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJtYXhSZXRyaWVzUmVzdWx0IiwicmV0cnkiLCJhc3NlbWJsZU9wZXJhdGlvbk5hbWUiLCJvcGVyYXRpb25JZCIsInRlbGVtZXRyeSIsImZ1bmN0aW9uSWQiLCJnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyIsIm1vZGVsIiwic2V0dGluZ3MiLCJfYTEzIiwicHJvdmlkZXIiLCJtb2RlbElkIiwicmVkdWNlIiwiYXR0cmlidXRlcyIsIm1ldGFkYXRhIiwidHJhY2UiLCJub29wVHJhY2VyIiwic3RhcnRTcGFuIiwibm9vcFNwYW4iLCJzdGFydEFjdGl2ZVNwYW4iLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJzcGFuQ29udGV4dCIsIm5vb3BTcGFuQ29udGV4dCIsInNldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZXMiLCJhZGRFdmVudCIsImFkZExpbmsiLCJhZGRMaW5rcyIsInNldFN0YXR1cyIsInVwZGF0ZU5hbWUiLCJpc1JlY29yZGluZyIsInJlY29yZEV4Y2VwdGlvbiIsInRyYWNlSWQiLCJzcGFuSWQiLCJ0cmFjZUZsYWdzIiwiZ2V0VHJhY2VyIiwiaXNFbmFibGVkIiwidHJhY2VyIiwiU3BhblN0YXR1c0NvZGUiLCJyZWNvcmRTcGFuIiwiZm4iLCJlbmRXaGVuRG9uZSIsInNwYW4iLCJzdGFjayIsImNvZGUiLCJFUlJPUiIsInNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzMiIsImlucHV0IiwicmVjb3JkSW5wdXRzIiwib3V0cHV0IiwicmVjb3JkT3V0cHV0cyIsImVtYmVkIiwibWF4UmV0cmllc0FyZyIsImFib3J0U2lnbmFsIiwiZXhwZXJpbWVudGFsX3RlbGVtZXRyeSIsImJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzIiwiSlNPTiIsInN0cmluZ2lmeSIsImVtYmVkZGluZyIsInVzYWdlIiwicmF3UmVzcG9uc2UiLCJkb0VtYmVkU3BhbiIsIm1vZGVsUmVzcG9uc2UiLCJkb0VtYmVkIiwidmFsdWVzIiwiZW1iZWRkaW5nMiIsImVtYmVkZGluZ3MiLCJ1c2FnZTIiLCJ0b2tlbnMiLCJOYU4iLCJtYXAiLCJlbWJlZGRpbmczIiwiRGVmYXVsdEVtYmVkUmVzdWx0Iiwib3B0aW9ucyIsInNwbGl0QXJyYXkiLCJhcnJheSIsImNodW5rU2l6ZSIsImkiLCJzbGljZSIsImVtYmVkTWFueSIsIm1heEVtYmVkZGluZ3NQZXJDYWxsIiwiZW1iZWRkaW5nczIiLCJlbWJlZGRpbmdzMyIsIkRlZmF1bHRFbWJlZE1hbnlSZXN1bHQiLCJ2YWx1ZUNodW5rcyIsImNodW5rIiwicmVzcG9uc2VFbWJlZGRpbmdzIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImdlbmVyYXRlSW1hZ2UiLCJwcm9tcHQiLCJuIiwic2l6ZSIsInByb3ZpZGVyT3B0aW9ucyIsImltYWdlcyIsImRvR2VuZXJhdGUiLCJEZWZhdWx0R2VuZXJhdGVJbWFnZVJlc3VsdCIsImJhc2U2NEltYWdlcyIsImJhc2U2NCIsInVpbnQ4QXJyYXkiLCJpbWFnZSIsImNyZWF0ZUlkR2VuZXJhdG9yIiwic2FmZVBhcnNlSlNPTiIsIkFJU0RLRXJyb3IzIiwibmFtZTMiLCJtYXJrZXIzIiwic3ltYm9sMyIsIl9hMyIsIk5vT2JqZWN0R2VuZXJhdGVkRXJyb3IiLCJjYXVzZSIsInRleHQiLCJ0ZXh0MiIsIkFJU0RLRXJyb3I0IiwibmFtZTQiLCJtYXJrZXI0Iiwic3ltYm9sNCIsIl9hNCIsIkRvd25sb2FkRXJyb3IiLCJ1cmwiLCJzdGF0dXNDb2RlIiwiZG93bmxvYWQiLCJmZXRjaEltcGxlbWVudGF0aW9uIiwiZmV0Y2giLCJ1cmxUZXh0IiwidG9TdHJpbmciLCJvayIsIlVpbnQ4QXJyYXkiLCJhcnJheUJ1ZmZlciIsIm1pbWVUeXBlIiwibWltZVR5cGVTaWduYXR1cmVzIiwiYnl0ZXMiLCJkZXRlY3RJbWFnZU1pbWVUeXBlIiwiZXZlcnkiLCJieXRlIiwiaW5kZXgiLCJjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MiIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJBSVNES0Vycm9yNSIsIm5hbWU1IiwibWFya2VyNSIsInN5bWJvbDUiLCJfYTUiLCJJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciIsImNvbnRlbnQiLCJ6IiwiZGF0YUNvbnRlbnRTY2hlbWEiLCJ1bmlvbiIsInN0cmluZyIsImluc3RhbmNlb2YiLCJBcnJheUJ1ZmZlciIsImN1c3RvbSIsIl9iIiwiZ2xvYmFsVGhpcyIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmciLCJjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkiLCJjb252ZXJ0VWludDhBcnJheVRvVGV4dCIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiQUlTREtFcnJvcjYiLCJuYW1lNiIsIm1hcmtlcjYiLCJzeW1ib2w2IiwiX2E2IiwiSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IiLCJyb2xlIiwic3BsaXREYXRhVXJsIiwiZGF0YVVybCIsImhlYWRlciIsImJhc2U2NENvbnRlbnQiLCJzcGxpdCIsImNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQiLCJtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzIiwibW9kZWxTdXBwb3J0c1VybCIsImRvd25sb2FkSW1wbGVtZW50YXRpb24iLCJkb3dubG9hZGVkQXNzZXRzIiwiZG93bmxvYWRBc3NldHMiLCJtZXNzYWdlcyIsInN5c3RlbSIsImNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlIiwicHJvdmlkZXJNZXRhZGF0YSIsImV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhIiwidHlwZSIsInBhcnQiLCJjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQiLCJmaWx0ZXIiLCJyZXN0IiwidG9vbENhbGxJZCIsInRvb2xOYW1lIiwiZXhwZXJpbWVudGFsX2NvbnRlbnQiLCJpc0Vycm9yIiwiX2V4aGF1c3RpdmVDaGVjayIsInVybHMiLCJBcnJheSIsImlzQXJyYXkiLCJmbGF0Iiwic3RhcnRzV2l0aCIsIlVSTCIsImRvd25sb2FkZWRJbWFnZXMiLCJmcm9tRW50cmllcyIsIm5vcm1hbGl6ZWREYXRhIiwicHJvdG9jb2wiLCJkYXRhVXJsTWltZVR5cGUiLCJkb3dubG9hZGVkRmlsZSIsInByZXBhcmVDYWxsU2V0dGluZ3MiLCJtYXhUb2tlbnMiLCJ0ZW1wZXJhdHVyZSIsInRvcFAiLCJ0b3BLIiwicHJlc2VuY2VQZW5hbHR5IiwiZnJlcXVlbmN5UGVuYWx0eSIsInN0b3BTZXF1ZW5jZXMiLCJzZWVkIiwiSW52YWxpZFByb21wdEVycm9yIiwic2FmZVZhbGlkYXRlVHlwZXMiLCJ6NyIsIno2IiwiejMiLCJ6MiIsImpzb25WYWx1ZVNjaGVtYSIsImxhenkiLCJudWxsIiwibnVtYmVyIiwiYm9vbGVhbiIsInJlY29yZCIsInByb3ZpZGVyTWV0YWRhdGFTY2hlbWEiLCJ6NSIsIno0IiwidG9vbFJlc3VsdENvbnRlbnRTY2hlbWEiLCJvYmplY3QiLCJsaXRlcmFsIiwib3B0aW9uYWwiLCJ0ZXh0UGFydFNjaGVtYSIsImltYWdlUGFydFNjaGVtYSIsImZpbGVQYXJ0U2NoZW1hIiwidG9vbENhbGxQYXJ0U2NoZW1hIiwiYXJncyIsInVua25vd24iLCJ0b29sUmVzdWx0UGFydFNjaGVtYSIsImNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hIiwiY29yZVVzZXJNZXNzYWdlU2NoZW1hIiwiY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEiLCJjb3JlVG9vbE1lc3NhZ2VTY2hlbWEiLCJjb3JlTWVzc2FnZVNjaGVtYSIsImRldGVjdFByb21wdFR5cGUiLCJjaGFyYWN0ZXJpc3RpY3MiLCJkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzIiwic29tZSIsImMiLCJpbmNsdWRlcyIsImF0dGFjaG1lbnRzVG9QYXJ0cyIsImF0dGFjaG1lbnRzIiwiX2MiLCJwYXJ0cyIsImF0dGFjaG1lbnQiLCJBSVNES0Vycm9yNyIsIm5hbWU3IiwibWFya2VyNyIsInN5bWJvbDciLCJfYTciLCJNZXNzYWdlQ29udmVyc2lvbkVycm9yIiwib3JpZ2luYWxNZXNzYWdlIiwiY29udmVydFRvQ29yZU1lc3NhZ2VzIiwidG9vbHMiLCJjb3JlTWVzc2FnZXMiLCJ0b29sSW52b2NhdGlvbnMiLCJleHBlcmltZW50YWxfYXR0YWNobWVudHMiLCJ0b29sSW52b2NhdGlvbiIsInRvb2wyIiwiZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQiLCJzdGFuZGFyZGl6ZVByb21wdCIsInByb21wdFR5cGUiLCJ2YWxpZGF0aW9uUmVzdWx0Iiwic2NoZW1hIiwic3VjY2VzcyIsImNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSIsInByb21wdFRva2VucyIsImNvbXBsZXRpb25Ub2tlbnMiLCJ0b3RhbFRva2VucyIsImFkZExhbmd1YWdlTW9kZWxVc2FnZSIsInVzYWdlMSIsIkRFRkFVTFRfU0NIRU1BX1BSRUZJWCIsIkRFRkFVTFRfU0NIRU1BX1NVRkZJWCIsIkRFRkFVTFRfR0VORVJJQ19TVUZGSVgiLCJpbmplY3RKc29uSW5zdHJ1Y3Rpb24iLCJzY2hlbWFQcmVmaXgiLCJzY2hlbWFTdWZmaXgiLCJsaW5lIiwiam9pbiIsImlzSlNPTkFycmF5IiwiaXNKU09OT2JqZWN0IiwiVHlwZVZhbGlkYXRpb25FcnJvciIsIlVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIiwic2FmZVZhbGlkYXRlVHlwZXMyIiwiYXNTY2hlbWEiLCJjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtIiwic291cmNlIiwiVHJhbnNmb3JtU3RyZWFtIiwiYXN5bmNJdGVyYXRvciIsIm5leHQiLCJub1NjaGVtYU91dHB1dFN0cmF0ZWd5IiwidmFsaWRhdGVQYXJ0aWFsUmVzdWx0IiwidGV4dERlbHRhIiwicGFydGlhbCIsInZhbGlkYXRlRmluYWxSZXN1bHQiLCJjb250ZXh0IiwiY3JlYXRlRWxlbWVudFN0cmVhbSIsImZ1bmN0aW9uYWxpdHkiLCJvYmplY3RPdXRwdXRTdHJhdGVneSIsImFycmF5T3V0cHV0U3RyYXRlZ3kiLCIkc2NoZW1hIiwiaXRlbVNjaGVtYSIsInByb3BlcnRpZXMiLCJlbGVtZW50cyIsIml0ZW1zIiwicmVxdWlyZWQiLCJhZGRpdGlvbmFsUHJvcGVydGllcyIsImxhdGVzdE9iamVjdCIsImlzRmlyc3REZWx0YSIsImlzRmluYWxEZWx0YSIsImlucHV0QXJyYXkiLCJyZXN1bHRBcnJheSIsImVsZW1lbnQiLCJwdWJsaXNoZWRFbGVtZW50Q291bnQiLCJvcmlnaW5hbFN0cmVhbSIsInB1Ymxpc2hlZEVsZW1lbnRzIiwidHJhbnNmb3JtIiwiZW51bU91dHB1dFN0cmF0ZWd5IiwiZW51bVZhbHVlcyIsImVudW0iLCJnZXRPdXRwdXRTdHJhdGVneSIsInZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0IiwibW9kZSIsInNjaGVtYU5hbWUiLCJzY2hlbWFEZXNjcmlwdGlvbiIsIm9yaWdpbmFsR2VuZXJhdGVJZCIsInByZWZpeCIsImdlbmVyYXRlT2JqZWN0IiwiaW5wdXRTY2hlbWEiLCJfaW50ZXJuYWwiLCJnZW5lcmF0ZUlkMyIsImN1cnJlbnREYXRlIiwiRGF0ZSIsIm91dHB1dFN0cmF0ZWd5IiwiZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlIiwiZmluaXNoUmVhc29uIiwid2FybmluZ3MiLCJyZXF1ZXN0IiwibG9ncHJvYnMiLCJyZXN1bHRQcm92aWRlck1ldGFkYXRhIiwic3RhbmRhcmRpemVkUHJvbXB0Iiwic3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyIsInByb21wdE1lc3NhZ2VzIiwic3VwcG9ydHNJbWFnZVVybHMiLCJzdXBwb3J0c1VybCIsImdlbmVyYXRlUmVzdWx0Iiwic3BhbjIiLCJfYTE0IiwiX2IyIiwiX2QiLCJfZSIsIl9mIiwicmVzdWx0MiIsImRlc2NyaXB0aW9uIiwiaW5wdXRGb3JtYXQiLCJyZXNwb25zZURhdGEiLCJpZCIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwib2JqZWN0VGV4dCIsIl9nIiwiX2giLCJ0b29sIiwicGFyYW1ldGVycyIsInRvb2xDYWxscyIsInBhcnNlUmVzdWx0IiwiRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0IiwidG9Kc29uUmVzcG9uc2UiLCJpbml0IiwiY3JlYXRlSWRHZW5lcmF0b3IyIiwiaXNEZWVwRXF1YWxEYXRhIiwicGFyc2VQYXJ0aWFsSnNvbiIsIkRlbGF5ZWRQcm9taXNlIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwicHJvbWlzZSIsInJlamVjdCIsImNhbGwiLCJjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSIsInJlcyIsInJlaiIsImNyZWF0ZVN0aXRjaGFibGVTdHJlYW0iLCJpbm5lclN0cmVhbVJlYWRlcnMiLCJpc0Nsb3NlZCIsIndhaXRGb3JOZXdTdHJlYW0iLCJwcm9jZXNzUHVsbCIsImNvbnRyb2xsZXJQYXJhbSIsInB1bGwiLCJjYW5jZWwiLCJhZGRTdHJlYW0iLCJpbm5lclN0cmVhbSIsIm5vdyIsInBlcmZvcm1hbmNlIiwib3JpZ2luYWxHZW5lcmF0ZUlkMiIsInN0cmVhbU9iamVjdCIsIm9uRmluaXNoIiwibm93MiIsIkRlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQiLCJpbnB1dFByb3ZpZGVyTWV0YWRhdGEiLCJvYmplY3RQcm9taXNlIiwidXNhZ2VQcm9taXNlIiwicHJvdmlkZXJNZXRhZGF0YVByb21pc2UiLCJ3YXJuaW5nc1Byb21pc2UiLCJyZXF1ZXN0UHJvbWlzZSIsInJlc3BvbnNlUHJvbWlzZSIsInN0aXRjaGFibGVTdHJlYW0iLCJzZWxmIiwicm9vdFNwYW4iLCJjYWxsT3B0aW9ucyIsInRyYW5zZm9ybWVyIiwiYXJnc1RleHREZWx0YSIsImRvU3RyZWFtU3BhbiIsInN0YXJ0VGltZXN0YW1wTXMiLCJkb1N0cmVhbVNwYW4yIiwiZG9TdHJlYW0iLCJvYmplY3QyIiwiYWNjdW11bGF0ZWRUZXh0IiwibGF0ZXN0T2JqZWN0SnNvbiIsImlzRmlyc3RDaHVuayIsInRyYW5zZm9ybWVkU3RyZWFtIiwibXNUb0ZpcnN0Q2h1bmsiLCJjdXJyZW50T2JqZWN0SnNvbiIsInN0YXRlIiwicGFyc2VTdGF0ZSIsImZsdXNoIiwiZmluYWxVc2FnZSIsImVycm9yMiIsInBhcnRpYWxPYmplY3RTdHJlYW0iLCJlbGVtZW50U3RyZWFtIiwidGV4dFN0cmVhbSIsImZ1bGxTdHJlYW0iLCJwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UiLCJ0b1RleHRTdHJlYW1SZXNwb25zZSIsImNyZWF0ZUlkR2VuZXJhdG9yMyIsIkFJU0RLRXJyb3IxMiIsIkFQSUNhbGxFcnJvcjIiLCJFbXB0eVJlc3BvbnNlQm9keUVycm9yIiwiSW52YWxpZFByb21wdEVycm9yMiIsIkludmFsaWRSZXNwb25zZURhdGFFcnJvciIsIkpTT05QYXJzZUVycm9yIiwiTG9hZEFQSUtleUVycm9yIiwiTm9Db250ZW50R2VuZXJhdGVkRXJyb3IiLCJOb1N1Y2hNb2RlbEVycm9yIiwiVHlwZVZhbGlkYXRpb25FcnJvcjIiLCJVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjIiLCJBSVNES0Vycm9yOCIsImdldEVycm9yTWVzc2FnZTIiLCJuYW1lOCIsIm1hcmtlcjgiLCJzeW1ib2w4IiwiX2E4IiwiSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciIsInRvb2xBcmdzIiwiQUlTREtFcnJvcjkiLCJuYW1lOSIsIm1hcmtlcjkiLCJzeW1ib2w5IiwiX2E5IiwiTm9TdWNoVG9vbEVycm9yIiwiYXZhaWxhYmxlVG9vbHMiLCJBSVNES0Vycm9yMTAiLCJnZXRFcnJvck1lc3NhZ2UzIiwibmFtZTEwIiwibWFya2VyMTAiLCJzeW1ib2wxMCIsIl9hMTAiLCJUb29sQ2FsbFJlcGFpckVycm9yIiwib3JpZ2luYWxFcnJvciIsIkFJU0RLRXJyb3IxMSIsImdldEVycm9yTWVzc2FnZTQiLCJuYW1lMTEiLCJtYXJrZXIxMSIsInN5bWJvbDExIiwiX2ExMSIsIlRvb2xFeGVjdXRpb25FcnJvciIsImFzU2NoZW1hMiIsImlzTm9uRW1wdHlPYmplY3QiLCJrZXlzIiwicHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSIsInRvb2xDaG9pY2UiLCJhY3RpdmVUb29scyIsImZpbHRlcmVkVG9vbHMiLCJ0b29sVHlwZSIsImV4aGF1c3RpdmVDaGVjayIsImxhc3RXaGl0ZXNwYWNlUmVnZXhwIiwic3BsaXRPbkxhc3RXaGl0ZXNwYWNlIiwibWF0Y2giLCJ3aGl0ZXNwYWNlIiwic3VmZml4IiwicmVtb3ZlVGV4dEFmdGVyTGFzdFdoaXRlc3BhY2UiLCJzYWZlUGFyc2VKU09OMiIsInNhZmVWYWxpZGF0ZVR5cGVzMyIsImFzU2NoZW1hMyIsInBhcnNlVG9vbENhbGwiLCJ0b29sQ2FsbCIsInJlcGFpclRvb2xDYWxsIiwiZG9QYXJzZVRvb2xDYWxsIiwicmVwYWlyZWRUb29sQ2FsbCIsInBhcmFtZXRlclNjaGVtYSIsInJlcGFpckVycm9yIiwidHJpbSIsInRvUmVzcG9uc2VNZXNzYWdlcyIsInRvb2xSZXN1bHRzIiwicmVzcG9uc2VNZXNzYWdlcyIsInRvb2xSZXN1bHQiLCJvcmlnaW5hbEdlbmVyYXRlSWQzIiwiZ2VuZXJhdGVUZXh0IiwibWF4U3RlcHMiLCJleHBlcmltZW50YWxfb3V0cHV0IiwiZXhwZXJpbWVudGFsX2NvbnRpbnVlU3RlcHMiLCJjb250aW51ZVN0ZXBzIiwiZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzIiwiZXhwZXJpbWVudGFsX3JlcGFpclRvb2xDYWxsIiwib25TdGVwRmluaXNoIiwiaW5pdGlhbFByb21wdCIsImluamVjdEludG9TeXN0ZW1Qcm9tcHQiLCJjYWxsU2V0dGluZ3MiLCJjdXJyZW50TW9kZWxSZXNwb25zZSIsImN1cnJlbnRUb29sQ2FsbHMiLCJjdXJyZW50VG9vbFJlc3VsdHMiLCJzdGVwQ291bnQiLCJzdGVwcyIsInN0ZXBUeXBlIiwicHJvbXB0Rm9ybWF0Iiwic3RlcElucHV0TWVzc2FnZXMiLCJfYTE1IiwiX2MyIiwiX2QyIiwiX2UyIiwiX2YyIiwicmVzcG9uc2VGb3JtYXQiLCJleGVjdXRlVG9vbHMiLCJjdXJyZW50VXNhZ2UiLCJuZXh0U3RlcFR5cGUiLCJvcmlnaW5hbFRleHQiLCJzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZCIsInRyaW1FbmQiLCJ0cmltU3RhcnQiLCJzdGVwVGV4dCIsImxhc3RNZXNzYWdlIiwiY3VycmVudFN0ZXBSZXN1bHQiLCJwYXJzZSIsImlzQ29udGludWVkIiwiRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCIsInBhcnNlT3V0cHV0IiwiaWdub3JlZCIsIm91dHB1dF9leHBvcnRzIiwic2FmZVBhcnNlSlNPTjMiLCJzYWZlVmFsaWRhdGVUeXBlczQiLCJhc1NjaGVtYTQiLCJjcmVhdGVJZEdlbmVyYXRvcjQiLCJmb3JtYXREYXRhU3RyZWFtUGFydDIiLCJtZXJnZVN0cmVhbXMiLCJzdHJlYW0xIiwic3RyZWFtMiIsInJlYWRlcjEiLCJyZWFkZXIyIiwibGFzdFJlYWQxIiwibGFzdFJlYWQyIiwic3RyZWFtMURvbmUiLCJzdHJlYW0yRG9uZSIsInJlYWRTdHJlYW0xIiwicmVhZFN0cmVhbTIiLCJyYWNlIiwidGhlbiIsInJ1blRvb2xzVHJhbnNmb3JtYXRpb24iLCJnZW5lcmF0b3JTdHJlYW0iLCJ0b29sQ2FsbFN0cmVhbWluZyIsInRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciIsInRvb2xSZXN1bHRzU3RyZWFtIiwiYWN0aXZlVG9vbENhbGxzIiwib3V0c3RhbmRpbmdUb29sUmVzdWx0cyIsIlNldCIsImNhbkNsb3NlIiwiZmluaXNoQ2h1bmsiLCJhdHRlbXB0Q2xvc2UiLCJmb3J3YXJkU3RyZWFtIiwiY2h1bmtUeXBlIiwidG9vbEV4ZWN1dGlvbklkIiwiYWRkIiwiZGVsZXRlIiwicGlwZVRvIiwiV3JpdGFibGVTdHJlYW0iLCJvcmlnaW5hbEdlbmVyYXRlSWQ0Iiwic3RyZWFtVGV4dCIsImV4cGVyaW1lbnRhbF90b29sQ2FsbFN0cmVhbWluZyIsImV4cGVyaW1lbnRhbF90cmFuc2Zvcm0iLCJvbkNodW5rIiwiRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQiLCJmaW5pc2hSZWFzb25Qcm9taXNlIiwidGV4dFByb21pc2UiLCJ0b29sQ2FsbHNQcm9taXNlIiwidG9vbFJlc3VsdHNQcm9taXNlIiwic3RlcHNQcm9taXNlIiwicmVjb3JkZWRTdGVwVGV4dCIsInJlY29yZGVkQ29udGludWF0aW9uVGV4dCIsInJlY29yZGVkRnVsbFRleHQiLCJyZWNvcmRlZFJlcXVlc3QiLCJyZWNvcmRlZFJlc3BvbnNlIiwicmVjb3JkZWRUb29sQ2FsbHMiLCJyZWNvcmRlZFRvb2xSZXN1bHRzIiwicmVjb3JkZWRGaW5pc2hSZWFzb24iLCJyZWNvcmRlZFVzYWdlIiwicmVjb3JkZWRQcm92aWRlck1ldGFkYXRhIiwicmVjb3JkZWRTdGVwcyIsImV2ZW50UHJvY2Vzc29yIiwic3RlcE1lc3NhZ2VzIiwiY3VycmVudFN0ZXAiLCJsYXN0U3RlcCIsImNsb3NlU3RyZWFtIiwiYmFzZVN0cmVhbSIsInJvb3RTcGFuQXJnIiwic3RyZWFtU3RlcCIsInN0ZXBUeXBlMiIsInByZXZpb3VzU3RlcFRleHQiLCJoYXNMZWFkaW5nV2hpdGVzcGFjZSIsInN0ZXBSZXF1ZXN0Iiwic3RlcFRvb2xDYWxscyIsInN0ZXBUb29sUmVzdWx0cyIsInN0ZXBGaW5pc2hSZWFzb24iLCJzdGVwVXNhZ2UiLCJzdGVwUHJvdmlkZXJNZXRhZGF0YSIsInN0ZXBGaXJzdENodW5rIiwiZnVsbFN0ZXBUZXh0Iiwic3RlcExvZ1Byb2JzIiwic3RlcFJlc3BvbnNlIiwiY2h1bmtCdWZmZXIiLCJjaHVua1RleHRQdWJsaXNoZWQiLCJpbldoaXRlc3BhY2VQcmVmaXgiLCJoYXNXaGl0ZXNwYWNlU3VmZml4IiwicHVibGlzaFRleHRDaHVuayIsInRyaW1tZWRDaHVua1RleHQiLCJtc1RvRmluaXNoIiwic3RlcFRvb2xDYWxsc0pzb24iLCJjb21iaW5lZFVzYWdlIiwidGVlU3RyZWFtIiwidGVlIiwidG9EYXRhU3RyZWFtSW50ZXJuYWwiLCJnZXRFcnJvck1lc3NhZ2U1Iiwic2VuZFVzYWdlIiwiYWdncmVnYXRlZFJlc3BvbnNlIiwiY2FsbGJhY2tUcmFuc2Zvcm1lciIsInN0cmVhbVBhcnRzVHJhbnNmb3JtZXIiLCJ0b0RhdGFTdHJlYW0iLCJtZXJnZUludG9EYXRhU3RyZWFtIiwid3JpdGVyIiwidG9EYXRhU3RyZWFtUmVzcG9uc2UiLCJzbW9vdGhTdHJlYW0iLCJkZWxheTIiLCJidWZmZXIiLCJ3aGl0ZXNwYWNlSW5kZXgiLCJzZWFyY2giLCJ3b3JkIiwiZXhwZXJpbWVudGFsX3dyYXBMYW5ndWFnZU1vZGVsIiwibWlkZGxld2FyZSIsInRyYW5zZm9ybVBhcmFtcyIsIndyYXBHZW5lcmF0ZSIsIndyYXBTdHJlYW0iLCJwcm92aWRlcklkIiwiZG9UcmFuc2Zvcm0iLCJwYXJhbXMiLCJzcGVjaWZpY2F0aW9uVmVyc2lvbiIsInRyYW5zZm9ybWVkUGFyYW1zIiwiTm9TdWNoTW9kZWxFcnJvcjIiLCJleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIiLCJsYW5ndWFnZU1vZGVscyIsInRleHRFbWJlZGRpbmdNb2RlbHMiLCJmYWxsYmFja1Byb3ZpZGVyIiwibGFuZ3VhZ2VNb2RlbCIsIm1vZGVsVHlwZSIsInRleHRFbWJlZGRpbmdNb2RlbCIsIkFJU0RLRXJyb3IxMyIsIk5vU3VjaE1vZGVsRXJyb3IzIiwibmFtZTEyIiwibWFya2VyMTIiLCJzeW1ib2wxMiIsIl9hMTIiLCJOb1N1Y2hQcm92aWRlckVycm9yIiwiYXZhaWxhYmxlUHJvdmlkZXJzIiwiZXJyb3JOYW1lIiwiTm9TdWNoTW9kZWxFcnJvcjQiLCJleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSIsInByb3ZpZGVycyIsInJlZ2lzdHJ5IiwiRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkiLCJyZWdpc3RlclByb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJzcGxpdElkIiwiaW5kZXhPZiIsInRleHRFbWJlZGRpbmciLCJjb3NpbmVTaW1pbGFyaXR5IiwidmVjdG9yMSIsInZlY3RvcjIiLCJkb3RQcm9kdWN0IiwibWFnbml0dWRlIiwiYWNjdW11bGF0b3IiLCJ2ZWN0b3IiLCJNYXRoIiwic3FydCIsIkFzc2lzdGFudFJlc3BvbnNlIiwidGhyZWFkSWQiLCJtZXNzYWdlSWQiLCJwcm9jZXNzMiIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJzZW5kTWVzc2FnZSIsImVuY29kZSIsInNlbmREYXRhTWVzc2FnZSIsInNlbmRFcnJvciIsImV2ZW50IiwiZGVsdGEiLCJsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzIiwiZm9ybWF0RGF0YVN0cmVhbVBhcnQzIiwiY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIiLCJjYWxsYmFja3MiLCJvblN0YXJ0Iiwib25Ub2tlbiIsIm9uVGV4dCIsIm9uQ29tcGxldGlvbiIsIm9uRmluYWwiLCJmb3J3YXJkQUlNZXNzYWdlQ2h1bmsiLCJUZXh0RGVjb2RlclN0cmVhbSIsImRhdGFTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsIml0ZW0iLCJsbGFtYWluZGV4X2FkYXB0ZXJfZXhwb3J0cyIsIm1lcmdlSW50b0RhdGFTdHJlYW0yIiwidG9EYXRhU3RyZWFtMiIsInRvRGF0YVN0cmVhbVJlc3BvbnNlMiIsImNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSIsImZvcm1hdERhdGFTdHJlYW1QYXJ0NCIsInRvRGF0YVN0cmVhbUludGVybmFsMiIsInRyaW1TdGFydE9mU3RyZWFtIiwiaXNTdHJlYW1TdGFydCIsImZvcm1hdERhdGFTdHJlYW1QYXJ0NSIsIkhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyIsIlN0cmVhbURhdGEiLCJlbmNvZGVyIiwid2FybmluZ1RpbWVvdXQiLCJwcm9jZXNzIiwiY29uc29sZSIsIndhcm4iLCJjbGVhclRpbWVvdXQiLCJhcHBlbmQiLCJhcHBlbmRNZXNzYWdlQW5ub3RhdGlvbiIsIkxhbmdDaGFpbkFkYXB0ZXIiLCJMbGFtYUluZGV4QWRhcHRlciIsIk91dHB1dCIsImV4cGVyaW1lbnRhbF9nZW5lcmF0ZUltYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ })

};
;